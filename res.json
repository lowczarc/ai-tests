[
  {
    "content": "use crate::audio::Audio;\nuse crate::consts::{BOOT_ROM_FILE, PROGRAM_START_ADDRESS, STACK_START_ADDRESS};\nuse crate::display::Display;\nuse std::fs::File;\nuse std::io::Read;\n\npub mod reg {\n    pub const B: u8 = 0;\n    pub const C: u8 = 1;\n    pub const D: u8 = 2;\n    pub const E: u8 = 3;\n    pub const H: u8 = 4;\n    pub const L: u8 = 5;\n    pub const A: u8 = 6;\n    pub const F: u8 = 7;\n\n    pub const BC: u8 = 0;\n    pub const DE: u8 = 1;\n    pub const HL: u8 = 2;\n    pub const SP: u8 = 3;\n}\n\npub mod flag {\n    pub const NZ: u8 = 0;\n    pub const Z: u8 = 1;\n    pub const NC: u8 = 2;\n    pub const C: u8 = 3;\n\n    pub const CY: u8 = 1 << 4;\n    pub const H: u8 = 1 << 5;\n    pub const N: u8 = 1 << 6;\n    pub const ZF: u8 = 1 << 7;\n}\n\n#[derive(Debug)]",
    "name": "state_chunk_0.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_0.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_0.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file contains the code for the state chunk of a Game Boy emulator. It defines constants for the registers and flags used in the emulator, as well as a debugging feature to print the state of the emulator.",
      "references": [
        {
          "name": "reg::B",
          "category": "pub mod",
          "description": "This constant represents the B register in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::C",
          "category": "pub mod",
          "description": "This constant represents the C register in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::D",
          "category": "pub mod",
          "description": "This constant represents the D register in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::E",
          "category": "pub mod",
          "description": "This constant represents the E register in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::H",
          "category": "pub mod",
          "description": "This constant represents the H register in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::L",
          "category": "pub mod",
          "description": "This constant represents the L register in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::A",
          "category": "pub mod",
          "description": "This constant represents the A register in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::F",
          "category": "pub mod",
          "description": "This constant represents the F register in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::BC",
          "category": "pub mod",
          "description": "This constant represents the BC register pair in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::DE",
          "category": "pub mod",
          "description": "This constant represents the DE register pair in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::HL",
          "category": "pub mod",
          "description": "This constant represents the HL register pair in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "reg::SP",
          "category": "pub mod",
          "description": "This constant represents the SP stack pointer register in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "flag::NZ",
          "category": "pub mod",
          "description": "This constant represents the NZ flag in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "flag::Z",
          "category": "pub mod",
          "description": "This constant represents the Z flag in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "flag::NC",
          "category": "pub mod",
          "description": "This constant represents the NC flag in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "flag::C",
          "category": "pub mod",
          "description": "This constant represents the C flag in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "flag::CY",
          "category": "pub mod",
          "description": "This constant represents the CY flag in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "flag::H",
          "category": "pub mod",
          "description": "This constant represents the H flag in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "flag::N",
          "category": "pub mod",
          "description": "This constant represents the N flag in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "flag::ZF",
          "category": "pub mod",
          "description": "This constant represents the ZF flag in the Game Boy CPU.",
          "publics": true
        },
        {
          "name": "state_chunk_0",
          "category": "struct",
          "description": "This struct is used to represent the state chunk of a Game Boy emulator.",
          "parameters": [],
          "returns": null
        }
      ],
      "examples": [
        {
          "title": "Print State",
          "description": "Prints the state of the emulator.",
          "example": "cargo run --bin emulator --state-chunk",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub struct CPU {\n    /* B, C, D, E, H, L, A, F registers.\n     * A is usually represented by 111 even though it's in index 6.\n     * (HL) usually takes the 110 representation.\n     * F isn't usually used by the 8bits register operations. */\n    pub r: [u8; 8],\n\n    pub pc: u16, // program counter\n    pub sp: u16, // stack pointer\n}",
    "name": "state_chunk_1.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_1.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_1.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file defines the CPU struct and its associated methods for the gameboy emulator. The CPU struct holds the registers (B, C, D, E, H, L, A, F) as an array of unsigned 8-bit integers. It also contains the program counter (pc) and stack pointer (sp) as unsigned 16-bit integers.",
      "references": [
        {
          "name": "CPU",
          "category": "structure",
          "description": "The CPU struct represents the central processing unit of the gameboy emulator. It holds the registers, program counter, and stack pointer.",
          "publics": true,
          "parameters": [],
          "returns": null
        },
        {
          "name": "CPU.r",
          "category": "structure",
          "description": "The r field is an array of uint8 values representing the 8-bit registers B, C, D, E, H, L, A, and F.",
          "publics": true,
          "parameters": [],
          "returns": null
        },
        {
          "name": "CPU.pc",
          "category": "structure",
          "description": "The pc field is a 16-bit unsigned integer representing the program counter.",
          "publics": true,
          "parameters": [],
          "returns": null
        },
        {
          "name": "CPU.sp",
          "category": "structure",
          "description": "The sp field is a 16-bit unsigned integer representing the stack pointer.",
          "publics": true,
          "parameters": [],
          "returns": null
        }
      ],
      "examples": [
        {
          "title": "Create a new CPU instance",
          "description": "Create a new instance of the CPU struct with default values.",
          "example": "let cpu = CPU { r: [0; 8], pc: 0, sp: 0 };",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "impl CPU {\n    pub fn new() -> Self {\n        Self {\n            r: [0; 8],\n\n            pc: PROGRAM_START_ADDRESS,\n            sp: STACK_START_ADDRESS,\n        }\n    }\n\n    pub fn r16(&self, r: u8) -> u16 {\n        if r == reg::SP {\n            return self.sp;\n        } else {\n            return self.r[r as usize * 2 + 1] as u16 | ((self.r[r as usize * 2] as u16) << 8);\n        }\n    }\n\n    pub fn w16(&mut self, r: u8, value: u16) {\n        if r == reg::SP {\n            self.sp = value;\n        } else {\n            self.r[r as usize * 2 + 1] = (value & 0xff) as u8;\n            self.r[r as usize * 2] = (value >> 8) as u8;\n        }\n    }\n\n    pub fn check_flag(&self, flag: u8) -> bool {\n        let f = self.r[reg::F as usize];\n\n        match flag {\n            flag::NZ => f >> 7 == 0,\n            flag::Z => f >> 7 == 1,\n            flag::NC => f >> 4 == 0,\n            flag::C => f >> 4 == 1,\n            _ => unimplemented!(),\n        }\n    }\n}",
    "name": "state_chunk_2.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_2.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_2.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file contains the implementation of various functions and methods for the CPU structure in a Gameboy emulator. It defines functions for initializing a CPU, fetching register values, writing register values, and checking flags. The CPU structure holds registers, program counter (pc), and stack pointer (sp). The 'new' function initializes the CPU structure with all registers set to 0, pc set to the program start address, and sp set to the stack start address. The 'r16' function takes a register value as input and returns the corresponding 16-bit value from the 'r' array. The 'w16' function writes a 16-bit value to a register in the 'r' array. The 'check_flag' function checks a specific flag in the 'F' register and returns a boolean value indicating its status. ",
      "references": [
        {
          "name": "new",
          "category": "method",
          "description": "Initializes the CPU structure with default values.",
          "parameters": [],
          "returns": {
            "type": "CPU",
            "description": "An instance of the CPU structure."
          },
          "prototype": "pub fn new() -> Self"
        },
        {
          "name": "r16",
          "category": "method",
          "description": "Returns the 16-bit value of a register.",
          "parameters": [
            {
              "name": "r",
              "type": "u8",
              "description": "The register value."
            }
          ],
          "returns": {
            "type": "u16",
            "description": "The corresponding 16-bit value of the register."
          },
          "prototype": "pub fn r16(&self, r: u8) -> u16"
        },
        {
          "name": "w16",
          "category": "method",
          "description": "Writes a 16-bit value to a register.",
          "parameters": [
            {
              "name": "r",
              "type": "u8",
              "description": "The register value."
            },
            {
              "name": "value",
              "type": "u16",
              "description": "The value to write to the register."
            }
          ],
          "returns": null,
          "prototype": "pub fn w16(&mut self, r: u8, value: u16)"
        },
        {
          "name": "check_flag",
          "category": "method",
          "description": "Checks the status of a flag in the 'F' register.",
          "parameters": [
            {
              "name": "flag",
              "type": "u8",
              "description": "The flag value."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "True if the flag is set, false otherwise."
          },
          "prototype": "pub fn check_flag(&self, flag: u8) -> bool"
        }
      ],
      "examples": [
        {
          "title": "Initializing a CPU",
          "description": "Create a new instance of the CPU structure with default values.",
          "example": "let cpu = CPU::new();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Getting a 16-bit register value",
          "description": "Retrieve the 16-bit value of register 'r'.",
          "example": "let register_value = cpu.r16(r);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Writing a 16-bit value to a register",
          "description": "Write 'value' to register 'r'.",
          "example": "cpu.w16(r, value);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Checking a flag",
          "description": "Check the status of a specific flag in the 'F' register.",
          "example": "let flag_status = cpu.check_flag(flag);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub struct Memory {\n    boot_rom: [u8; 0x100],\n    pub boot_rom_on: bool,\n\n    // 32 KiB ROM bank 00\n    rom: [u8; 0x8000],\n\n    // 4 KiB Work RAM 00\n    wram_00: [u8; 0x1000],\n\n    // 4 KiB Work RAM 00\n    wram_01: [u8; 0x1000],\n\n    // 8 KiB Video RAM\n    pub display: Display,\n\n    pub io: [u8; 0x80],\n\n    // High RAM\n    hram: [u8; 0x7f],\n\n    pub audio: Audio,\n\n    pub ime: bool,\n\n    pub interrupts_register: u8,\n}\n\n#[derive(Debug)]\npub enum MemError {\n    WritingToROM,\n    Unimplemented,\n    NotUsable,\n}",
    "name": "state_chunk_3.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_3.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_3.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "The file 'state_chunk_3.rs' contains the definition of a struct called 'Memory' and an enum called 'MemError'. The 'Memory' struct represents the memory of a Game Boy emulator and contains various fields such as boot ROM, ROM banks, work RAM, video RAM, display, I/O registers, high RAM, audio, and interrupt-related fields. The 'MemError' enum represents the possible errors that can occur during memory operations.",
      "references": [
        {
          "name": "Memory",
          "category": "struct",
          "description": "The 'Memory' struct represents the memory of a Game Boy emulator.",
          "publics": true,
          "parameters": [],
          "returns": null
        },
        {
          "name": "MemError",
          "category": "enum",
          "description": "The 'MemError' enum represents the possible errors that can occur during memory operations.",
          "publics": false,
          "enum": [
            "WritingToROM",
            "Unimplemented",
            "NotUsable"
          ],
          "parameters": [],
          "returns": null
        }
      ],
      "examples": [
        {
          "title": "Accessing Memory Fields",
          "description": "This example demonstrates how to access the fields of the 'Memory' struct.",
          "example": "let memory = Memory::new();\n\n// Accessing the 'boot_rom_on' field\nlet boot_rom_on = memory.boot_rom_on;\n\n// Modifying the 'rom' field\nmemory.rom[0x100] = 0xAB;\n\n// Accessing the 'display' field\nlet display = &memory.display;\n\n// Accessing the 'io' field\nlet io = &memory.io;",
          "example_markdown_language": "rust"
        },
        {
          "title": "Handling MemError",
          "description": "This example demonstrates how to handle the possible 'MemError' enum variants.",
          "example": "fn write_to_memory(memory: &mut Memory) -> Result<(), MemError> {\n    // Attempt to write to the ROM\n    if memory.boot_rom_on {\n        return Err(MemError::WritingToROM);\n    }\n\n    // Perform some unimplemented operation\n    // ...\n    // return Err(MemError::Unimplemented);\n\n    // Check if the memory is usable\n    if !is_memory_usable(&memory) {\n        return Err(MemError::NotUsable);\n    }\n\n    Ok(())\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "impl Memory {\n    pub fn new() -> Self {\n        let mut display = Display::new();\n\n        display.cls();\n\n        Self {\n            boot_rom: [0; 0x100],\n            boot_rom_on: true,\n            rom: [0; 0x8000],\n            wram_00: [0; 0x1000],\n            wram_01: [0; 0x1000],\n            display,\n            io: [0; 0x80],\n            hram: [0; 0x7f],\n            audio: Audio::new(),\n            ime: false,\n            interrupts_register: 0,\n        }\n    }\n\n    pub fn load_boot_rom(&mut self) -> Result<(), std::io::Error> {\n        let mut f = File::open(BOOT_ROM_FILE)?;\n\n        f.read(&mut self.boot_rom)?;\n\n        Ok(())\n    }\n\n    pub fn load_rom(&mut self, file: &str) -> Result<(), std::io::Error> {\n        let mut f = File::open(file)?;\n\n        f.read(&mut self.rom)?;\n\n        Ok(())\n    }",
    "name": "state_chunk_4.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_4.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_4.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file contains the implementation of the `Memory` struct for a Game Boy emulator. The `Memory` struct represents the memory of the Game Boy and provides methods for initializing the memory, loading the boot ROM and game ROM, and accessing the different memory regions.",
      "references": [
        {
          "name": "Memory::new",
          "category": "method",
          "description": "Creates a new `Memory` instance with initialized memory and display.",
          "parameters": [],
          "returns": {
            "type": "Memory",
            "description": "A new `Memory` instance."
          }
        },
        {
          "name": "Memory::load_boot_rom",
          "category": "method",
          "description": "Loads the boot ROM into the `boot_rom` memory region.",
          "errors": [
            {
              "name": "std::io::Error",
              "description": "An I/O error occurred while reading the boot ROM file."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), std::io::Error>",
            "description": "Result indicating success or failure of loading the boot ROM."
          }
        },
        {
          "name": "Memory::load_rom",
          "category": "method",
          "description": "Loads the game ROM into the `rom` memory region.",
          "errors": [
            {
              "name": "std::io::Error",
              "description": "An I/O error occurred while reading the game ROM file."
            }
          ],
          "parameters": [
            {
              "name": "file",
              "type": "&str",
              "description": "The path to the game ROM file."
            }
          ],
          "returns": {
            "type": "Result<(), std::io::Error>",
            "description": "Result indicating success or failure of loading the game ROM."
          }
        }
      ],
      "examples": [
        {
          "title": "Create Memory Instance",
          "description": "Create a new `Memory` instance and initialize the memory.",
          "example": "let memory = Memory::new();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Load Boot ROM",
          "description": "Load the boot ROM file into the `boot_rom` memory region.",
          "example": "memory.load_boot_rom().expect(\"Failed to load boot ROM\");",
          "example_markdown_language": "rust"
        },
        {
          "title": "Load Game ROM",
          "description": "Load a game ROM file into the `rom` memory region.",
          "example": "memory.load_rom(\"game.gb\").expect(\"Failed to load ROM\");",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn r(&self, addr: u16) -> Result<u8, MemError> {\n        if addr < 0x100 && self.boot_rom_on {\n            Ok(self.boot_rom[addr as usize])\n        } else if addr < 0x8000 {\n            Ok(self.rom[addr as usize])\n        } else if addr >= 0xc000 && addr < 0xd000 {\n            Ok(self.wram_00[addr as usize - 0xc000])\n        } else if addr >= 0xe000 && addr < 0xf000 {\n            Ok(self.wram_00[addr as usize - 0xe000])\n        } else if addr >= 0xd000 && addr < 0xe000 {\n            Ok(self.wram_01[addr as usize - 0xd000])\n        } else if (addr >= 0x8000 && addr < 0xa000) || (addr >= 0xfe00 && addr < 0xfea0) {\n            self.display.r(addr & !0x8000)\n        } else if addr >= 0xff00 && addr < 0xff80 {\n            Ok(self.r_io((addr & 0xff) as u8))\n        } else if addr >= 0xff80 && addr < 0xffff {\n            Ok(self.hram[addr as usize - 0xff80])\n        } else if addr == 0xffff {\n            Ok(self.interrupts_register)\n        } else {\n            // println!(",
    "name": "state_chunk_5.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_5.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_5.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file contains the implementation of the `r` function, which is used to read a byte from different memory regions based on the provided address in a Game Boy emulator. The function handles various memory regions and returns the corresponding value based on the address. It also includes error handling for possible memory errors that may occur during the read operation.",
      "references": [
        {
          "name": "r",
          "category": "method",
          "description": "Reads a byte from memory based on the provided address.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs when accessing memory."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u16",
              "description": "The address from which to read the byte."
            }
          ],
          "returns": {
            "type": "Result<u8, MemError>",
            "description": "The byte read from the memory when successful, or an error if a memory error occurs."
          },
          "prototype": "fn r(&self, addr: u16) -> Result<u8, MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example: Read from ROM",
          "description": "Reads a byte from the ROM memory region.",
          "example": "let address = 0x4000;\nlet byte = emulator.r(address).unwrap();  // Read byte from ROM",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example: Read from RAM",
          "description": "Reads a byte from the WRAM memory region.",
          "example": "let address = 0xC200;\nlet byte = emulator.r(address).unwrap();  // Read byte from WRAM",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example: Read from Display",
          "description": "Reads a byte from the display memory region.",
          "example": "let address = 0x8002;\nlet byte = emulator.r(address).unwrap();  // Read byte from display",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "//     \"Trying to read at address 0x{:04x} which is unimplemented\",\n            //     addr\n            // );\n            Ok(0) //Err(MemError::Unimplemented)\n        }\n    }",
    "name": "state_chunk_6.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_6.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_6.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file contains the code for reading from the memory in the Game Boy emulator. The provided content includes a commented code where an address is being read but the implementation is unimplemented. The function returns a Result enum with an Ok variant if the read is successful and an Err variant with a MemError enum if the read is unimplemented.",
      "references": [
        {
          "name": "read_memory",
          "category": "function",
          "description": "This function reads data from memory at the specified address.",
          "errors": [
            {
              "name": "MemError::Unimplemented",
              "description": "This error occurs when trying to read from an unimplemented address."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u16",
              "description": "The memory address to read from."
            }
          ],
          "returns": {
            "type": "Result<u8, MemError>",
            "description": "Returns a Result enum with an Ok variant containing the read data if successful, or an Err variant containing a MemError if the address is unimplemented."
          }
        }
      ],
      "examples": [
        {
          "title": "Reading from memory",
          "description": "This example demonstrates how to use the read_memory function to read data from memory.",
          "example": "// Launch the emulator\n<base_command>\n\n// Read data from memory\nlet addr = 0x1234;\nmatch read_memory(addr) {\n    Ok(data) => {\n        println!(\"Data read: {:02x}\", data);\n    }\n    Err(err) => {\n        match err {\n            MemError::Unimplemented => {\n                println!(\"Trying to read from an unimplemented address\");\n            }\n        }\n    }\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn w(&mut self, addr: u16, value: u8) -> Result<(), MemError> {\n        if addr < 0x100 && self.boot_rom_on {\n            self.boot_rom[addr as usize] = value;\n            Ok(())\n        } else if addr < 0x8000 {\n            self.rom[addr as usize] = value;\n            Ok(())\n        } else if addr >= 0xc000 && addr < 0xd000 {\n            self.wram_00[addr as usize - 0xc000] = value;\n            Ok(())\n        } else if addr >= 0xe000 && addr < 0xf000 {\n            self.wram_00[addr as usize - 0xe000] = value;\n            Ok(())\n        } else if addr >= 0xd000 && addr < 0xe000 {\n            self.wram_01[addr as usize - 0xd000] = value;\n            Ok(())\n        } else if (addr >= 0x8000 && addr < 0xa000) || (addr >= 0xfe00 && addr < 0xfea0) {\n            self.display.w(addr & !0x8000, value)\n        } else if addr >= 0xff00 && addr < 0xff80 {\n            Ok(self.w_io((addr & 0xff) as u8, value)?)\n        } else if addr >= 0xff80 && addr < 0xffff {",
    "name": "state_chunk_7.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_7.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_7.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file contains the implementation of the `w` function which is a method of the `StateChunk` struct. The `w` function is responsible for writing a value to different memory regions based on the provided address. It handles various memory regions such as the boot ROM, ROM, and different areas of WRAM. It also handles writing to the display and I/O registers. The function returns a `Result` type with the `Ok` variant returning `()` indicating a successful write, and the `Err` variant returning a `MemError` which represents any potential errors that may occur during the write operation.",
      "references": [
        {
          "name": "w",
          "category": "method",
          "description": "Writes a value to the memory based on the provided address.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error representing any potential errors that may occur during memory write operation."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u16",
              "description": "The address where the value should be written."
            },
            {
              "name": "value",
              "type": "u8",
              "description": "The value to be written."
            }
          ],
          "returns": {
            "type": "()",
            "description": "Returns `Ok(())` indicating a successful write operation."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Writes a value to a specific address in memory.",
          "example": "rust -m emulator::state_chunk_7::w --addr 0x8000 --value 0x0A",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 2",
          "description": "Writes a value to the display memory.",
          "example": "rust -m emulator::state_chunk_7::w --addr 0xFEFF --value 0x55",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 3",
          "description": "Writes a value to the I/O register.",
          "example": "rust -m emulator::state_chunk_7::w --addr 0xFF00 --value 0x80",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "self.hram[addr as usize - 0xff80] = value;\n            Ok(())\n        } else if addr == 0xffff {\n            self.interrupts_register = value;\n            Ok(())\n        } else {\n            // println!(\n            //     \"Trying to write at address 0x{:04x} which is unimplemented\",\n            //     addr\n            // );\n            Ok(()) //Err(MemError::Unimplemented)\n        }\n    }\n}",
    "name": "state_chunk_8.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_8.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_8.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file, state_chunk_8.rs, is part of the Game Boy emulator project. It defines a struct called StateChunk8, which is responsible for managing and updating various memory registers of the Game Boy hardware. The 'set_byte' method in this file is used to write a value to a specific memory address. If the address is in the range 0xff80-0xfffe, it writes the value to the corresponding index in the 'hram' array. If the address is 0xffff, it updates the 'interrupts_register' field. Otherwise, it returns an Ok(()) result as the address is unimplemented. The file also includes commented out code for printing a message when writing to an unimplemented address.",
      "references": [
        {
          "name": "StateChunk8",
          "category": "structure",
          "description": "A struct that manages and updates memory registers of the Game Boy hardware.",
          "subreferences": [
            {
              "name": "set_byte",
              "category": "method",
              "description": "Writes a value to a specific memory address.",
              "errors": [
                {
                  "name": "Unimplemented",
                  "description": "Returned when trying to write to an unimplemented memory address."
                }
              ],
              "parameters": [
                {
                  "name": "addr",
                  "type": "u16",
                  "description": "The address to write the value to."
                },
                {
                  "name": "value",
                  "type": "u8",
                  "description": "The value to write to the address."
                }
              ],
              "returns": {
                "type": "Result<(), MemError>",
                "description": "Ok(()) if the write operation is successful, otherwise Err(MemError::Unimplemented)."
              },
              "example": "// Example: Writing a value to a memory address\n\nfn main() {\n    let mut state_chunk = StateChunk8::new();\n    let addr = 0x1234;\n    let value = 0xAB;\n    let result = state_chunk.set_byte(addr, value);\n\n    match result {\n        Ok(()) => println!(\"Write operation successful!\"),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}",
              "example_markdown_language": "rust"
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example: Writing a value to a memory address",
          "description": "This example demonstrates how to use the 'set_byte' method to write a value to a specific memory address using the StateChunk8 struct.",
          "example": "// Example: Writing a value to a memory address\n\nfn main() {\n    let mut state_chunk = StateChunk8::new();\n    let addr = 0x1234;\n    let value = 0xAB;\n    let result = state_chunk.set_byte(addr, value);\n\n    match result {\n        Ok(()) => println!(\"Write operation successful!\"),\n        Err(err) => println!(\"Error: {}\", err),\n    }\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub struct GBState {\n    pub cpu: CPU,\n    pub mem: Memory,\n}",
    "name": "state_chunk_9.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_9.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_9.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file defines the `GBState` struct which represents the state of a Game Boy emulator. It contains two public fields: `cpu` of type `CPU` and `mem` of type `Memory`.",
      "references": [
        {
          "name": "GBState",
          "category": "structure",
          "description": "The `GBState` struct represents the state of a Game Boy emulator.",
          "publics": true,
          "parameters": [],
          "returns": null
        },
        {
          "name": "cpu",
          "category": "structure",
          "description": "The `cpu` field of the `GBState` struct represents the central processing unit of the Game Boy.",
          "publics": true,
          "parameters": [],
          "returns": null
        },
        {
          "name": "mem",
          "category": "structure",
          "description": "The `mem` field of the `GBState` struct represents the memory of the Game Boy.",
          "publics": true,
          "parameters": [],
          "returns": null
        }
      ],
      "examples": [
        {
          "title": "Creating a GBState object",
          "description": "This example demonstrates how to create a `GBState` object and access its fields.",
          "example": "let state = GBState { cpu: CPU::new(), mem: Memory::new() };",
          "example_markdown_language": "rust"
        },
        {
          "title": "Accessing the cpu field",
          "description": "This example demonstrates how to access the `cpu` field of a `GBState` object.",
          "example": "let cpu = state.cpu;",
          "example_markdown_language": "rust"
        },
        {
          "title": "Accessing the mem field",
          "description": "This example demonstrates how to access the `mem` field of a `GBState` object.",
          "example": "let mem = state.mem;",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "impl GBState {\n    pub fn new() -> Self {\n        let mut mem = Memory::new();\n\n        mem.load_boot_rom().unwrap();\n\n        Self {\n            cpu: CPU::new(),\n            mem,\n        }\n    }\n\n    pub fn r_reg(&self, r_i: u8) -> Result<u8, MemError> {\n        if r_i < 6 {\n            Ok(self.cpu.r[r_i as usize])\n        } else if r_i == 7 {\n            Ok(self.cpu.r[6])\n        } else if r_i == 6 {\n            self.mem.r(self.cpu.r16(reg::HL))\n        } else {\n            panic!(\"r_i must be a 3 bits register input number\")\n        }\n    }\n\n    pub fn w_reg(&mut self, r_i: u8, value: u8) -> Result<(), MemError> {\n        if r_i < 6 {\n            self.cpu.r[r_i as usize] = value;\n        } else if r_i == 7 {\n            self.cpu.r[6] = value;\n        } else if r_i == 6 {\n            self.mem.w(self.cpu.r16(reg::HL), value)?;\n        } else {\n            panic!(\"r_i must be a 3 bits register input number\")\n        }\n        Ok(())\n    }\n}",
    "name": "state_chunk_10.rs",
    "path": "/home/lancelot/gameboy/emulator/src/state_chunk_10.rs",
    "originalPath": "/home/lancelot/gameboy/emulator/src/state_chunk_10.rs",
    "chunkTotal": 11,
    "reference_json": {
      "description": "This file contains the implementation of a GBState struct, which represents the state of a Game Boy emulator. The GBState struct has various functions for manipulating registers and memory. The `new` function creates a new GBState object and initializes its memory and CPU. The `r_reg` function reads a register value from the CPU or memory, returning an Ok result with the value or an Err result if a memory access error occurs. The `w_reg` function writes a value to a register in the CPU or memory, returning an Ok result if successful or an Err result if a memory access error occurs. The file is part of a larger project for emulating a Game Boy console.",
      "references": [
        {
          "name": "GBState::new",
          "category": "method",
          "description": "Creates a new GBState object and initializes its memory and CPU.",
          "parameters": [],
          "returns": {
            "type": "GBState",
            "description": "The newly created GBState object."
          }
        },
        {
          "name": "GBState::r_reg",
          "category": "method",
          "description": "Reads a register value from the CPU or memory.",
          "parameters": [
            {
              "name": "r_i",
              "type": "u8",
              "description": "The register input number to read from."
            }
          ],
          "returns": {
            "type": "Result<u8, MemError>",
            "description": "An Ok result containing the register value if successful, or an Err result with a MemError if a memory access error occurs."
          }
        },
        {
          "name": "GBState::w_reg",
          "category": "method",
          "description": "Writes a value to a register in the CPU or memory.",
          "parameters": [
            {
              "name": "r_i",
              "type": "u8",
              "description": "The register input number to write to."
            },
            {
              "name": "value",
              "type": "u8",
              "description": "The value to write to the register."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "An Ok result if the write is successful, or an Err result with a MemError if a memory access error occurs."
          }
        }
      ],
      "examples": [
        {
          "title": "Creating a new GBState object",
          "description": "This example demonstrates how to create a new GBState object using the `new` function.",
          "example": "from gameboy.emulator.src.state_chunk_10.rs import GBState\n\nstate = GBState.new()\n\n# Display the CPU registers\nprint(state.cpu.r)\n\n# Display the initial memory contents\nprint(state.mem)",
          "example_markdown_language": "python"
        },
        {
          "title": "Reading a register value",
          "description": "This example demonstrates how to read a register value from the CPU or memory using the `r_reg` function.",
          "example": "from gameboy.emulator.src.state_chunk_10.rs import GBState\n\nstate = GBState.new()\n\n# Read register R3 from the CPU\nvalue = state.r_reg(3)\n\nif isinstance(value, Ok):\n    print('Register R3:', value.unwrap())\nelse:\n    print('Error:', value.unwrap_err())",
          "example_markdown_language": "python"
        },
        {
          "title": "Writing a value to a register",
          "description": "This example demonstrates how to write a value to a register in the CPU or memory using the `w_reg` function.",
          "example": "from gameboy.emulator.src.state_chunk_10.rs import GBState\nfrom gameboy.emulator.src.mem_error import MemError\n\nstate = GBState.new()\n\n# Write the value 10 to register R5 in the CPU\nresult = state.w_reg(5, 10)\n\nif isinstance(result, Ok):\n    print('Write successful')\nelse:\n    print('Error:', result.unwrap_err())",
          "example_markdown_language": "python"
        }
      ]
    },
    "chunk": 1
  }
]