[
  {
    "path": "Cargo.toml",
    "name": "Cargo.toml",
    "content": "[package]\nname = \"emulator\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nminifb = \"0.24\"\nrodio = \"0.17\"\n\n[profile.dev]\noverflow-checks = false\n",
    "reference_json": {
      "description": "This JSON object provides example code and references for the content of the Cargo.toml file. It includes code snippets and comments explaining their functionality, as well as possible errors that may occur.",
      "references": [
        {
          "name": "emulator",
          "category": "package",
          "description": "A Rust package for an emulator.",
          "errors": [
            {
              "name": "ParsingError",
              "description": "An error that occurs when parsing the Cargo.toml file."
            }
          ]
        },
        {
          "name": "minifb",
          "category": "dependency",
          "description": "A Rust library for creating cross-platform graphical applications.",
          "parameters": [
            {
              "name": "window_title",
              "type": "String",
              "description": "The title of the application window."
            }
          ],
          "returns": {
            "type": "Result<(), minifb::Error>",
            "description": "Returns a result indicating success or an error."
          },
          "prototype": "fn main_window(window_title: String) -> Result<(), minifb::Error>"
        },
        {
          "name": "rodio",
          "category": "dependency",
          "description": "A Rust audio playback library.",
          "parameters": [
            {
              "name": "file_path",
              "type": "String",
              "description": "The path of the audio file to play."
            }
          ],
          "returns": {
            "type": "Result<rodio::Sink, rodio::decoder::DecoderError>",
            "description": "Returns a result containing the audio sink or an error."
          },
          "prototype": "fn play_audio(file_path: String) -> Result<rodio::Sink, rodio::decoder::DecoderError>"
        }
      ],
      "examples": [
        {
          "title": "Example Usage",
          "description": "An example of using the functions defined in the Cargo.toml file.",
          "example": "```bash\n# Example Usage\n\n# Compile and run the emulator\ncargo run\n\n# Create a main window with the specified title\nemulator/main_window \"Emulator Window\"\n\n# Play an audio file\nemulator/play_audio \"audio.wav\"\n```",
          "example_markdown_language": "bash"
        }
      ]
    },
    "originalPath": "Cargo.toml",
    "chunk": 1
  },
  {
    "path": "src/audio.rs",
    "name": "audio.rs",
    "content": "use rodio::{OutputStream, Sink, Source};\n\nuse std::time::Duration;\n\nconst SAMPLE_RATE: u32 = 50000;\n\n#[derive(Clone, Debug)]\npub struct Wave {\n    period_value: u16,\n    num_sample: usize,\n    duty: f32,\n\n    env_initial_volume: f32,\n    env_direction: f32,\n    env_sweep_pace: u8,\n}\n\nimpl Wave {\n    pub fn new(\n        period_value: u16,\n        duty: u8,\n        env_initial_volume: u8,\n        env_direction: u8,\n        env_sweep_pace: u8,\n    ) -> Wave {\n        Wave {\n            period_value,\n            num_sample: 0,\n            duty: [0.125, 0.25, 0.5, 0.75][duty as usize],\n            env_initial_volume: env_initial_volume as f32,\n            env_direction: if env_direction == 0 { -1. } else { 1. },\n            env_sweep_pace,\n        }\n    }\n}\n\nimpl Iterator for Wave {\n    type Item = f32;\n\n    fn next(&mut self) -> Option<f32> {\n        self.num_sample = self.num_sample.wrapping_add(1);\n\n        if self.period_value == 0 {\n            return None;\n        }\n\n        let envelope_time = if self.env_sweep_pace != 0 {\n            (self.num_sample as f32 / SAMPLE_RATE as f32) * 64. / self.env_sweep_pace as f32\n        } else {\n            0.\n        };\n\n        let envelope = self.env_initial_volume + (self.env_direction * envelope_time);\n\n        let envelope_boundaries = if envelope > 16. {\n            16.\n        } else if envelope < 0. {\n            0.\n        } else {\n            envelope\n        };\n\n        let sign = if (8. * 32768. / (SAMPLE_RATE as f32) * self.num_sample as f32\n            / (2048. - self.period_value as f32))\n            % 2.\n            > 2. * self.duty\n        {\n            -1.\n        } else {\n            1.\n        };\n\n        Some(sign * envelope_boundaries / 64.)\n    }\n}\n\nimpl Source for Wave {\n    fn current_frame_len(&self) -> Option<usize> {\n        None\n    }\n\n    fn channels(&self) -> u16 {\n        1\n    }\n\n    fn sample_rate(&self) -> u32 {\n        SAMPLE_RATE\n    }\n\n    fn total_duration(&self) -> Option<Duration> {\n        None\n    }\n}\n\npub struct AudioChannel {\n    _stream: OutputStream,\n    sink: Sink,\n    pub on: bool,\n    pub period_value: u16,\n    pub duty: u8,\n}\n\nimpl AudioChannel {\n    pub fn new() -> Self {\n        let (stream, stream_handle) = OutputStream::try_default().unwrap();\n\n        Self {\n            _stream: stream,\n            sink: Sink::try_new(&stream_handle).unwrap(),\n            on: true,\n            period_value: 0,\n            duty: 0,\n        }\n    }\n\n    pub fn update(&mut self) {\n        if self.on {\n            self.sink.stop();\n            let source = Wave::new(self.period_value, self.duty, 0xf, 0, 3).amplify(0.25);\n            self.sink.append(source);\n        } else {\n            self.sink.stop();\n        }\n    }\n}\n\npub struct Audio {\n    pub ch1: AudioChannel,\n    pub ch2: AudioChannel,\n}\n\nimpl Audio {\n    pub fn new() -> Self {\n        Self {\n            ch1: AudioChannel::new(),\n            ch2: AudioChannel::new(),\n        }\n    }\n}\n",
    "reference_json": {
      "description": "This file contains the implementation of audio-related functionality in a Rust project. It defines structs and methods for generating waveforms and managing audio channels. The code defines a struct `Wave` that represents a waveform with properties such as period value, duty cycle, and envelope. It implements the `Iterator` trait to generate the waveform samples. The code also includes a struct `AudioChannel` that manages an audio channel with properties such as period value and duty cycle. It provides methods to update the state of the channel and control audio playback. Finally, there is a struct `Audio` that represents the overall audio component, managing multiple audio channels.",
      "references": [
        {
          "name": "Wave",
          "category": "struct",
          "description": "Represents a waveform with properties such as period value, duty cycle, and envelope. Implements the `Iterator` trait to generate the waveform samples.",
          "parameters": [
            {
              "name": "period_value",
              "type": "u16",
              "description": "The period (length) of the waveform in samples."
            },
            {
              "name": "duty",
              "type": "u8",
              "description": "The duty cycle of the waveform, ranging from 0 to 3."
            },
            {
              "name": "env_initial_volume",
              "type": "u8",
              "description": "The initial volume of the waveform envelope, ranging from 0 to 255."
            },
            {
              "name": "env_direction",
              "type": "u8",
              "description": "The direction of the waveform envelope, either -1 or 1."
            },
            {
              "name": "env_sweep_pace",
              "type": "u8",
              "description": "The pace at which the waveform envelope sweeps, ranging from 0 to 255."
            }
          ],
          "methods": [
            {
              "name": "new",
              "category": "function",
              "description": "Creates a new `Wave` with the specified period value, duty cycle, envelope properties, and returns it.",
              "parameters": [
                {
                  "name": "period_value",
                  "type": "u16",
                  "description": "The period (length) of the waveform in samples."
                },
                {
                  "name": "duty",
                  "type": "u8",
                  "description": "The duty cycle of the waveform, ranging from 0 to 3."
                },
                {
                  "name": "env_initial_volume",
                  "type": "u8",
                  "description": "The initial volume of the waveform envelope, ranging from 0 to 255."
                },
                {
                  "name": "env_direction",
                  "type": "u8",
                  "description": "The direction of the waveform envelope, either -1 or 1."
                },
                {
                  "name": "env_sweep_pace",
                  "type": "u8",
                  "description": "The pace at which the waveform envelope sweeps, ranging from 0 to 255."
                }
              ]
            }
          ],
          "returns": {
            "type": "Wave",
            "description": "A new `Wave` object."
          }
        },
        {
          "name": "AudioChannel",
          "category": "struct",
          "description": "Represents an audio channel with properties such as period value and duty cycle. Provides methods to update the state of the channel and control audio playback.",
          "methods": [
            {
              "name": "new",
              "category": "function",
              "description": "Creates a new `AudioChannel` with default properties and returns it."
            },
            {
              "name": "update",
              "category": "method",
              "description": "Updates the state of the `AudioChannel` based on its current settings. If the channel is on, it stops the current audio playback, creates a new `Wave` source based on the current period value and duty cycle, and appends it to the audio sink."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "AudioChannel",
            "description": "A new `AudioChannel` object."
          }
        },
        {
          "name": "Audio",
          "category": "struct",
          "description": "Represents the overall audio component, managing multiple audio channels.",
          "methods": [
            {
              "name": "new",
              "category": "function",
              "description": "Creates a new `Audio` object with default settings and returns it."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Audio",
            "description": "A new `Audio` object."
          }
        },
        {
          "name": "Wave.next",
          "category": "method",
          "description": "Generates the next sample of the waveform. It calculates the envelope volume, envelope boundaries, and waveform sign based on the current sample number, period value, duty cycle, and envelope properties.",
          "returns": {
            "type": "Option<f32>",
            "description": "The generated sample as a floating-point value if there are more samples to generate, otherwise returns `None`."
          },
          "parameters": []
        },
        {
          "name": "Wave.current_frame_len",
          "category": "method",
          "description": "Returns `None` as the `Wave` struct is not a fixed-length source.",
          "returns": {
            "type": "Option<usize>",
            "description": "`None`"
          },
          "parameters": []
        },
        {
          "name": "Wave.channels",
          "category": "method",
          "description": "Returns the number of audio channels, which is always 1 for `Wave`.",
          "returns": {
            "type": "u16",
            "description": "1"
          },
          "parameters": []
        },
        {
          "name": "Wave.sample_rate",
          "category": "method",
          "description": "Returns the sample rate of the waveform.",
          "returns": {
            "type": "u32",
            "description": "The sample rate constant `SAMPLE_RATE` defined in the code."
          },
          "parameters": []
        },
        {
          "name": "Wave.total_duration",
          "category": "method",
          "description": "Returns `None` as the `Wave` struct does not have a fixed total duration.",
          "returns": {
            "type": "Option<Duration>",
            "description": "`None`"
          },
          "parameters": []
        },
        {
          "name": "AudioChannel.update",
          "category": "method",
          "description": "Updates the state of the `AudioChannel` based on its current settings. If the channel is on, it stops the current audio playback, creates a new `Wave` source based on the current period value and duty cycle, and appends it to the audio sink.",
          "parameters": []
        },
        {
          "name": "Audio.new",
          "category": "method",
          "description": "Creates a new `Audio` object with default settings and returns it.",
          "parameters": []
        }
      ],
      "examples": [
        {
          "title": "Generate Waveform",
          "description": "This example demonstrates how to create a `Wave` object with specific settings and generate a waveform using it.",
          "example": "// Import required modules (not included in this code fragment)\n\n// Create a new Wave\nlet period_value = 16;\nlet duty = 2;\nlet env_initial_volume = 128;\nlet env_direction = 1;\nlet env_sweep_pace = 32;\nlet wave = Wave::new(period_value, duty, env_initial_volume, env_direction, env_sweep_pace);\n\n// Generate and print waveform samples\nfor sample in wave.take(10) {\n    println!(\"{:?}\", sample);\n}",
          "example_markdown_language": "rust"
        },
        {
          "title": "Create Audio Channel",
          "description": "This example demonstrates how to create a new `AudioChannel` and configure its properties.",
          "example": "// Create a new AudioChannel\nlet channel = AudioChannel::new();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Update Audio Channel",
          "description": "This example demonstrates how to update the state of an `AudioChannel` and control audio playback.",
          "example": "// Create a new AudioChannel\nlet mut channel = AudioChannel::new();\n\n// Update the channel state and start audio playback\nchannel.update();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Create Audio Component",
          "description": "This example demonstrates how to create a new `Audio` component with default settings.",
          "example": "// Create a new Audio component\nlet audio = Audio::new();",
          "example_markdown_language": "rust"
        }
      ]
    },
    "originalPath": "src/audio.rs",
    "chunk": 1
  },
  {
    "path": "src/consts.rs",
    "name": "consts.rs",
    "content": "pub const BOOT_ROM_FILE: &str = \"./assets/boot.bin\";\npub const PROGRAM_START_ADDRESS: u16 = 0x0;\npub const STACK_START_ADDRESS: u16 = 0x0;\n\npub const DISPLAY_UPDATE_RATE: u64 = 60; // Hertz\npub const DISPLAY_UPDATE_SLEEP_TIME_MICROS: u64 = 1000000 / DISPLAY_UPDATE_RATE;\n\npub const CPU_CLOCK_SPEED: u64 = 4_194_304;\npub const CPU_CYCLE_LENGTH_NANOS: u64 = 1_000_000_000 / CPU_CLOCK_SPEED;\n",
    "reference_json": {
      "description": "The provided content is a Rust file, consts.rs, which defines several constants. These constants include file paths, memory addresses, display update rate, CPU clock speed, and CPU cycle length. Example code will demonstrate how to use these constants and explain their purpose.",
      "references": [
        {
          "name": "BOOT_ROM_FILE",
          "category": "constant",
          "description": "A string constant representing the file path to the boot binary file.",
          "parameters": [],
          "returns": {
            "type": "str",
            "description": "The file path as a string."
          }
        },
        {
          "name": "PROGRAM_START_ADDRESS",
          "category": "constant",
          "description": "A constant representing the start address of the program in memory.",
          "parameters": [],
          "returns": {
            "type": "u16",
            "description": "The start address as a 16-bit unsigned integer."
          }
        },
        {
          "name": "STACK_START_ADDRESS",
          "category": "constant",
          "description": "A constant representing the start address of the stack in memory.",
          "parameters": [],
          "returns": {
            "type": "u16",
            "description": "The start address as a 16-bit unsigned integer."
          }
        },
        {
          "name": "DISPLAY_UPDATE_RATE",
          "category": "constant",
          "description": "A constant representing the update rate of the display in Hertz (Hz).",
          "parameters": [],
          "returns": {
            "type": "u64",
            "description": "The update rate as a 64-bit unsigned integer."
          }
        },
        {
          "name": "DISPLAY_UPDATE_SLEEP_TIME_MICROS",
          "category": "constant",
          "description": "A constant representing the sleep time in microseconds for the display update.",
          "parameters": [],
          "returns": {
            "type": "u64",
            "description": "The sleep time as a 64-bit unsigned integer."
          }
        },
        {
          "name": "CPU_CLOCK_SPEED",
          "category": "constant",
          "description": "A constant representing the clock speed of the CPU in Hertz (Hz).",
          "parameters": [],
          "returns": {
            "type": "u64",
            "description": "The clock speed as a 64-bit unsigned integer."
          }
        },
        {
          "name": "CPU_CYCLE_LENGTH_NANOS",
          "category": "constant",
          "description": "A constant representing the length of a CPU cycle in nanoseconds.",
          "parameters": [],
          "returns": {
            "type": "u64",
            "description": "The cycle length as a 64-bit unsigned integer."
          }
        }
      ],
      "examples": [
        {
          "title": "Using the BOOT_ROM_FILE constant",
          "description": "Load the boot binary file path using the BOOT_ROM_FILE constant.",
          "example": "// Rust example:\nlet boot_file_path = BOOT_ROM_FILE;\n// The constant BOOT_ROM_FILE would contain the file path to the boot binary file.",
          "example_markdown_language": "rust"
        },
        {
          "title": "Getting the PROGRAM_START_ADDRESS and STACK_START_ADDRESS",
          "description": "Retrieve the program start address and stack start address from the respective constants.",
          "example": "// Rust example:\nlet program_start_address = PROGRAM_START_ADDRESS;\nlet stack_start_address = STACK_START_ADDRESS;\n// The constants PROGRAM_START_ADDRESS and STACK_START_ADDRESS would contain the memory addresses.",
          "example_markdown_language": "rust"
        },
        {
          "title": "Setting the DISPLAY_UPDATE_RATE",
          "description": "Change the display update rate to a new value.",
          "example": "// Rust example:\nDISPLAY_UPDATE_RATE = 30;\n// The constant DISPLAY_UPDATE_RATE can be updated with a new value, for example, changing it to 30 Hz.",
          "example_markdown_language": "rust"
        },
        {
          "title": "Calculating the CPU_CYCLE_LENGTH_NANOS",
          "description": "Calculate the length of a CPU cycle in nanoseconds using the CPU_CLOCK_SPEED constant.",
          "example": "// Rust example:\nlet cpu_cycle_length = 1_000_000_000 / CPU_CLOCK_SPEED;\n// The constant CPU_CLOCK_SPEED can be used to calculate the length of a CPU cycle.",
          "example_markdown_language": "rust"
        }
      ]
    },
    "originalPath": "src/consts.rs",
    "chunk": 1
  },
  {
    "path": "src/interrupts.rs",
    "name": "interrupts.rs",
    "content": "use crate::opcodes;\nuse crate::state::{GBState, MemError};\n\nimpl GBState {\n    pub fn check_interrupts(&mut self) -> Result<(), MemError> {\n        if self.mem.ime {\n            let interrupts = self.mem.io[0x0f] & self.mem.interrupts_register;\n            if interrupts & 1 == 1 {\n                opcodes::push(self, self.cpu.pc)?;\n\n                self.mem.ime = false;\n                self.cpu.pc = 0x40;\n\n                self.mem.io[0x0f] &= !1;\n            }\n        }\n        Ok(())\n    }\n}\n",
    "reference_json": {
      "description": "This file, interrupts.rs, contains the implementation of interrupt handling in a Game Boy emulator. It defines a method, check_interrupts, that checks for pending interrupts and handles them accordingly. If interrupts are enabled, the method checks the interrupt flags and the interrupt enable flag. If an interrupt is pending, it pushes the current program counter (pc) onto the stack, disables interrupts, and sets the pc to 0x40. Finally, it clears the interrupted flag by bitwise AND'ing the interrupt flags with the inverse of 1.",
      "references": [
        {
          "name": "check_interrupts",
          "category": "method",
          "description": "Checks for pending interrupts and handles them if enabled.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when accessing memory."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns Ok(()) if interrupts were checked successfully, otherwise returns an Err with a MemError."
          },
          "publics": true,
          "prototype": "pub fn check_interrupts(&mut self) -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Handling Interrupts",
          "description": "Example code that shows how to use the check_interrupts method to handle pending interrupts.",
          "example": "// Import the necessary modules\nuse crate::opcodes;\nuse crate::state::{GBState, MemError};\n\nimpl GBState {\n    // Define the check_interrupts method\n    pub fn check_interrupts(&mut self) -> Result<(), MemError> {\n        if self.mem.ime {\n            let interrupts = self.mem.io[0x0f] & self.mem.interrupts_register;\n            if interrupts & 1 == 1 {\n                // Push the current program counter onto the stack\n                opcodes::push(self, self.cpu.pc)?;\n\n                // Disable interrupts and set the pc to 0x40\n                self.mem.ime = false;\n                self.cpu.pc = 0x40;\n\n                // Clear the interrupted flag\n                self.mem.io[0x0f] &= !1;\n            }\n        }\n        Ok(())\n    }\n}\n\n// Create an instance of GBState\nlet mut gb_state = GBState::new();\n\n// Enable interrupts\ngb_state.mem.ime = true;\n\n// Set the interrupt flags\ngb_state.mem.io[0x0f] = 0b0000_0001;\n\n// Set the interrupts_register\ngb_state.mem.interrupts_register = 0b0000_0001;\n\n// Invoke the check_interrupts method\nlet result = gb_state.check_interrupts();\n\n// Handle the result\nmatch result {\n    Ok(()) => println!(\"Interrupts checked successfully!\"),\n    Err(error) => println!(\"Error: {}\", error),\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "originalPath": "src/interrupts.rs",
    "chunk": 1
  },
  {
    "path": "src/main.rs",
    "name": "main.rs",
    "content": "pub mod audio;\npub mod consts;\npub mod display;\npub mod interrupts;\npub mod io;\npub mod opcodes;\npub mod state;\npub mod tests;\n\nuse crate::state::{GBState, MemError};\nuse std::env;\nuse std::{thread, time};\n\npub fn exec_opcode(state: &mut GBState) -> Result<u64, MemError> {\n    let opcode = state.mem.r(state.cpu.pc)?;\n\n    state.cpu.pc += 1;\n\n    let n1 = (opcode >> 3) & 0b111;\n    let n2 = opcode & 0b111;\n\n    match opcode >> 6 {\n        0b00 => opcodes::op00(state, n1, n2),\n        0b01 => opcodes::op01(state, n1, n2),\n        0b10 => opcodes::op10(state, n1, n2),\n        0b11 => opcodes::op11(state, n1, n2),\n        _ => panic!(),\n    }\n}\n\nfn main() {\n    if env::args().len() != 2 {\n        println!(\"Usage: gameboy-emulator <rom.gb>\");\n        return;\n    }\n\n    let rom = env::args().nth(1);\n\n    println!(\"Starting {:?}...\", rom.clone().unwrap());\n\n    let mut state = GBState::new();\n    let mut cycles = 0;\n\n    state.mem.load_rom(&rom.unwrap()).unwrap();\n\n    loop {\n        let c = exec_opcode(&mut state).unwrap();\n\n        // The OS scheduler is not precise enough to sleep at every iteration.\n        // The workaround is to sleep every 10000 cycles and keep track of the\n        // remaining cycles.\n        if cycles >= 10000 {\n            thread::sleep(time::Duration::from_nanos(\n                cycles * consts::CPU_CYCLE_LENGTH_NANOS,\n            ));\n            cycles = 0;\n        }\n        cycles += c;\n\n        let vblank_interrupt = state.mem.display.update_display(c);\n\n        if vblank_interrupt {\n            state.mem.io[0x0f] |= 1;\n        }\n\n        state.check_interrupts().unwrap();\n    }\n}\n",
    "reference_json": {
      "description": "This JSON object provides example code and references for the functions defined in the main.rs file. The main.rs file contains code for a Game Boy emulator. It includes modules for audio, constants, display, interrupts, I/O, opcodes, state, and tests. The 'exec_opcode' function executes a single opcode and returns the number of cycles taken. The 'main' function is the entry point of the program and runs the emulator in a loop. It loads a ROM file specified as a command line argument and executes opcodes until interrupted. The example code demonstrates how to use the 'exec_opcode' function and run the emulator with a ROM file specified as a command line argument.",
      "references": [
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes a single opcode and returns the number of cycles taken.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while accessing memory."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the Game Boy state."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The number of cycles taken as a result of executing the opcode."
          },
          "prototype": "fn exec_opcode(state: &mut GBState) -> Result<u64, MemError>"
        },
        {
          "name": "main",
          "category": "function",
          "description": "The entry point of the program. Runs the emulator in a loop.",
          "subreferences": [
            {
              "name": "GBState",
              "category": "type",
              "description": "Represents the state of the Game Boy.",
              "keywords": [
                "game",
                "boy"
              ]
            },
            {
              "name": "MemError",
              "category": "type",
              "description": "An error occurred while accessing memory."
            }
          ],
          "returns": null,
          "prototype": "fn main()"
        }
      ],
      "examples": [
        {
          "title": "Executing an Opcode",
          "description": "This example demonstrates how to use the 'exec_opcode' function.",
          "example": "// Example code\n\nlet mut state = GBState::new();\nlet mut opcode = 0xAB;\n\nlet result = exec_opcode(&mut state, opcode);\n\nprintln!(\"Cycles taken: {:?}\", result.unwrap());",
          "example_markdown_language": "rust"
        },
        {
          "title": "Running the Game Boy Emulator",
          "description": "This example demonstrates how to run the Game Boy emulator with a ROM file specified as a command line argument.",
          "example": "# Command line usage\n$ cargo run --bin gameboy-emulator rom.gb\n\n// Example code\n\nuse std::env;\n\n// Check command line arguments\nif env::args().len() != 2 {\n    println!(\"Usage: gameboy-emulator <rom.gb>\");\n    return;\n}\n\nlet rom = env::args().nth(1);\n\nprintln!(\"Starting {:?}...\", rom.clone().unwrap());\n\nlet mut state = GBState::new();\n\n// Load ROM\nstate.mem.load_rom(&rom.unwrap()).unwrap();\n\n// Emulator loop\nloop {\n    let c = exec_opcode(&mut state).unwrap();\n\n    // Sleep every 10000 cycles\n    if cycles >= 10000 {\n        thread::sleep(time::Duration::from_nanos(\n            cycles * consts::CPU_CYCLE_LENGTH_NANOS,\n        ));\n        cycles = 0;\n    }\n    cycles += c;\n\n    let vblank_interrupt = state.mem.display.update_display(c);\n\n    if vblank_interrupt {\n        state.mem.io[0x0f] |= 1;\n    }\n\n    state.check_interrupts().unwrap();\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "originalPath": "src/main.rs",
    "chunk": 1
  },
  {
    "path": "src/tests/mod.rs",
    "name": "mod.rs",
    "content": "#[cfg(test)]\npub mod instructions_tests;\n",
    "reference_json": {
      "description": "This file `src/tests/mod.rs` contains unit tests for the instructions module. It is a part of the project's test suite and is used to verify the correctness of the instructions implementation.",
      "references": [
        {
          "name": "mod",
          "category": "structure",
          "description": "A Rust keyword used to define a module.",
          "keywords": [
            "Rust",
            "module",
            "define"
          ],
          "publics": false
        },
        {
          "name": "instructions_tests",
          "category": "module",
          "description": "A module that contains unit tests for the instructions module.",
          "errors": [
            {
              "name": "ModuleNotFound",
              "description": "The `instructions_tests` module could not be found."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "An example that demonstrates the usage of the `mod` keyword.",
          "example": "extern crate my_crate;\n\nmod instructions_tests { }",
          "example_markdown_language": "rust"
        }
      ]
    },
    "originalPath": "src/tests/mod.rs",
    "chunk": 1
  },
  {
    "content": "use crate::consts::DISPLAY_UPDATE_SLEEP_TIME_MICROS;\nuse crate::state::MemError;\nuse minifb::{Window, WindowOptions};\nuse std::time::SystemTime;\n\nconst COLORS: [u32; 4] = [0x00e0f8d0, 0x0088c070, 0x346856, 0x00081820];\n\nconst LINE_DOTS: u64 = 456;\n\n#[derive(Debug)]\npub struct Display {\n    window: Window,\n    framebuffer: [u32; 160 * 144],\n\n    tiledata: [u8; 0x1800],\n    tilemaps: [u8; 0x800],\n\n    pub palette: u8,\n    pub viewport_y: u8,\n    pub viewport_x: u8,\n    pub lcdc: u8,\n    pub ly: u8,\n\n    last_dt: SystemTime,\n\n    stat: u64,\n}",
    "name": "display_chunk_0.rs",
    "path": "src/display_chunk_0.rs",
    "originalPath": "src/display_chunk_0.rs",
    "chunkTotal": 6,
    "reference_json": {
      "description": "This file defines the `Display` struct and related constants and methods for the Game Boy display. It uses the `minifb` crate to create a window and manages the framebuffer which stores the color information for each pixel. The `Display` struct also contains other state variables like `tiledata`, `tilemaps`, `palette`, `viewport_y`, `viewport_x`, `lcdc`, `ly`, `last_dt`, and `stat`. The file provides implementations for initializing the display, updating the framebuffer, and managing the display state.",
      "references": [
        {
          "name": "Display",
          "category": "struct",
          "description": "A struct representing the Game Boy display.",
          "parameters": [],
          "returns": null,
          "subreferences": [
            {
              "name": "new",
              "category": "method",
              "description": "Creates a new `Display` instance and initializes the window and framebuffer.",
              "parameters": [
                {
                  "name": "title",
                  "type": "String",
                  "description": "The title for the window."
                },
                {
                  "name": "scale",
                  "type": "u32",
                  "description": "The scale factor for the window size."
                }
              ],
              "returns": {
                "type": "Result<Display, String>",
                "description": "A `Result` containing the `Display` instance if successful, or an error message."
              }
            },
            {
              "name": "update_framebuffer",
              "category": "method",
              "description": "Updates the framebuffer with the current display state.",
              "parameters": [],
              "returns": null
            },
            {
              "name": "render",
              "category": "method",
              "description": "Renders the current framebuffer to the window.",
              "parameters": [],
              "returns": null
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Usage example",
          "description": "Create a new display, update the framebuffer, and render the display.",
          "example": "```rust\nuse crate::state::MemError;\nuse minifb::{Window, WindowOptions};\nuse std::time::SystemTime;\n\nconst COLORS: [u32; 4] = [0x00e0f8d0, 0x0088c070, 0x346856, 0x00081820];\n\nconst LINE_DOTS: u64 = 456;\n\n#[derive(Debug)]\npub struct Display {\n    window: Window,\n    framebuffer: [u32; 160 * 144],\n\n    tiledata: [u8; 0x1800],\n    tilemaps: [u8; 0x800],\n\n    pub palette: u8,\n    pub viewport_y: u8,\n    pub viewport_x: u8,\n    pub lcdc: u8,\n    pub ly: u8,\n\n    last_dt: SystemTime,\n\n    stat: u64,\n}\n\nimpl Display {\n    pub fn new(title: String, scale: u32) -> Result<Display, String> {\n        // Implementation goes here\n    }\n\n    pub fn update_framebuffer(&mut self) {\n        // Implementation goes here\n    }\n\n    pub fn render(&self) {\n        // Implementation goes here\n    }\n}\n```",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "impl Display {\n    pub fn new() -> Self {\n        Self {\n            window: Window::new(\"Gameboy Emulator\", 512, 461, WindowOptions::default()).unwrap(),\n            framebuffer: [0; 160 * 144],\n            tiledata: [0; 0x1800],\n            tilemaps: [0; 0x800],\n            palette: 0,\n            viewport_y: 0,\n            viewport_x: 0,\n            lcdc: 0,\n            ly: 0,\n            last_dt: SystemTime::now(),\n            stat: 0,\n        }\n    }\n\n    pub fn cls(&mut self) {\n        self.framebuffer = [COLORS[0]; 160 * 144];\n    }\n\n    pub fn update(&mut self) {\n        self.window\n            .update_with_buffer(&self.framebuffer, 160, 144)\n            .unwrap();\n    }",
    "name": "display_chunk_1.rs",
    "path": "src/display_chunk_1.rs",
    "originalPath": "src/display_chunk_1.rs",
    "chunkTotal": 6,
    "reference_json": {
      "description": "The file src/display_chunk_1.rs contains the implementation of the Display struct, which represents the display of a Gameboy emulator. It provides functions for initializing the display, clearing the frame buffer, and updating the display. The Display struct has various fields including the window, framebuffer, tiledata, tilemaps, palette, viewport_y, viewport_x, lcdc, ly, last_dt, and stat. The example code below demonstrates how to create a new Display, clear the frame buffer, and update the display.",
      "references": [
        {
          "name": "Display::new",
          "category": "method",
          "description": "Creates a new instance of the Display struct.",
          "parameters": [],
          "returns": {
            "type": "Display",
            "description": "A new instance of the Display struct."
          }
        },
        {
          "name": "Display::cls",
          "category": "method",
          "description": "Clears the frame buffer by setting all pixels to the default color.",
          "parameters": [],
          "returns": null,
          "errors": []
        },
        {
          "name": "Display::update",
          "category": "method",
          "description": "Updates the display by showing the contents of the frame buffer on the window.",
          "parameters": [],
          "returns": null,
          "errors": []
        }
      ],
      "examples": [
        {
          "title": "Example",
          "description": "Create a new Display, clear the frame buffer, and update the display.",
          "example": "use crate::display_chunk_1::Display;\n\nfn main() {\n    let mut display = Display::new();\n    display.cls();\n    display.update();\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn color_palette(&self, color_byte: u8) -> u32 {\n        COLORS[((self.palette >> (color_byte << 1)) & 0b11) as usize]\n    }\n\n    pub fn print_tile(&mut self, tile: u8, x: u8, y: u8, i: usize) {\n        let tile_pointer = if (self.lcdc >> 4) & 1 == 1 {\n            ((tile as u16) << 4) as usize\n        } else {\n            ((tile as u16) << 4) as usize + 0x800\n        };\n        for b in (0..8).rev() {\n            let data = (((self.tiledata[tile_pointer + i * 2] as u8) >> b) & 1)\n                | ((((self.tiledata[tile_pointer + i * 2 + 1] as u8) >> b) & 1) << 1);\n\n            let pxx = x as i32 * 8 + 7 - b as i32 - self.viewport_x as i32;\n            let pxy = ((y as i32 * 8) + i as i32) - self.viewport_y as i32;",
    "name": "display_chunk_2.rs",
    "path": "src/display_chunk_2.rs",
    "originalPath": "src/display_chunk_2.rs",
    "chunkTotal": 6,
    "reference_json": {
      "description": "This file contains two functions related to displaying graphics on a screen. The `color_palette` function returns the RGB color value corresponding to a given color byte. The `print_tile` function prints a tile on the screen at a specified location. These functions are used in a display chunk rendering process.",
      "references": [
        {
          "name": "color_palette",
          "category": "method",
          "description": "Returns the RGB color value corresponding to a given color byte.",
          "parameters": [
            {
              "name": "color_byte",
              "type": "u8",
              "description": "The color byte to convert to an RGB color value."
            }
          ],
          "returns": {
            "type": "u32",
            "description": "The RGB color value corresponding to the given color byte."
          },
          "prototype": "pub fn color_palette(&self, color_byte: u8) -> u32"
        },
        {
          "name": "print_tile",
          "category": "method",
          "description": "Prints a tile on the screen at the specified location.",
          "parameters": [
            {
              "name": "tile",
              "type": "u8",
              "description": "The tile to print."
            },
            {
              "name": "x",
              "type": "u8",
              "description": "The X-coordinate of the tile's top-left corner."
            },
            {
              "name": "y",
              "type": "u8",
              "description": "The Y-coordinate of the tile's top-left corner."
            },
            {
              "name": "i",
              "type": "usize",
              "description": "An index within the tile's data."
            }
          ],
          "errors": [
            {
              "name": "OutOfBoundError",
              "description": "Thrown if the tile index is out of bounds."
            }
          ],
          "prototype": "pub fn print_tile(&mut self, tile: u8, x: u8, y: u8, i: usize)"
        }
      ],
      "examples": [
        {
          "title": "Example 1: Using the 'color_palette' method",
          "description": "Printing the RGB value of a color byte.",
          "example": "fn main() {\n    let display_chunk = DisplayChunk::new();\n    let color_byte = 15;\n    let rgb_value = display_chunk.color_palette(color_byte);\n    println!(\"The RGB value for color byte {} is {:06X}\", color_byte, rgb_value);\n}",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2: Using the 'print_tile' method",
          "description": "Printing a tile on the screen at a specified location.",
          "example": "fn main() {\n    let mut display_chunk = DisplayChunk::new();\n    let tile = 5;\n    let x = 10;\n    let y = 20;\n    let i = 2;\n    display_chunk.print_tile(tile, x, y, i);\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "if pxy < 144 && pxx < 160 && pxy >= 0 && pxx >= 0 {\n                self.framebuffer[pxy as usize * 160 + pxx as usize] = self.color_palette(data);\n            }\n        }\n    }\n    pub fn print_all_tiles(&mut self) {\n        for i in 0..=255 {\n            for b in 0..8 {\n                self.print_tile(i, i % 20, i / 20, b);\n            }\n        }\n    }\n\n    pub fn w(&mut self, addr: u16, value: u8) -> Result<(), MemError> {\n        if addr < 0x1800 {\n            self.tiledata[addr as usize] = value;\n        } else {\n            self.tilemaps[addr as usize - 0x1800] = value;\n        }\n        Ok(())\n    }",
    "name": "display_chunk_3.rs",
    "path": "src/display_chunk_3.rs",
    "originalPath": "src/display_chunk_3.rs",
    "chunkTotal": 6,
    "reference_json": {
      "description": "This file contains the code for displaying and printing tiles. It includes functions for setting the color palette and printing all tiles on the screen. It also includes a function for writing data to the tile data and tile maps memory addresses.",
      "references": [
        {
          "name": "display_chunk_3",
          "category": "structure",
          "description": "A structure that represents the display chunk 3.",
          "subreferences": [
            {
              "name": "framebuffer",
              "category": "method",
              "description": "Sets the color of a pixel in the framebuffer based on the provided data.",
              "parameters": [
                {
                  "name": "pxy",
                  "type": "i32",
                  "description": "The y-coordinate of the pixel."
                },
                {
                  "name": "pxx",
                  "type": "i32",
                  "description": "The x-coordinate of the pixel."
                },
                {
                  "name": "data",
                  "type": "u8",
                  "description": "The data used to determine the color of the pixel."
                }
              ],
              "returns": null
            },
            {
              "name": "print_all_tiles",
              "category": "method",
              "description": "Prints all the tiles on the screen.",
              "parameters": [],
              "returns": null
            },
            {
              "name": "w",
              "category": "method",
              "description": "Writes a value to the tile data or tile maps memory addresses.",
              "parameters": [
                {
                  "name": "addr",
                  "type": "u16",
                  "description": "The memory address."
                },
                {
                  "name": "value",
                  "type": "u8",
                  "description": "The value to be written."
                }
              ],
              "returns": {
                "type": "Result<(), MemError>",
                "description": "Returns `Ok` if the write operation is successful, otherwise returns an error of type `MemError`."
              }
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Set the color of a pixel in the framebuffer.",
          "example": "cargo run",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 2",
          "description": "Print all tiles on the screen.",
          "example": "cargo run",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 3",
          "description": "Write a value to the tile data memory address.",
          "example": "cargo run",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 4",
          "description": "Write a value to the tile maps memory address.",
          "example": "cargo run",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn r(&self, addr: u16) -> Result<u8, MemError> {\n        if addr < 0x1800 {\n            Ok(self.tiledata[addr as usize])\n        } else {\n            Ok(self.tilemaps[addr as usize - 0x1800])\n        }\n    }\n\n    pub fn print_tile_map1(&mut self) {\n        let tilemap_pointer = if (self.lcdc >> 3) & 1 == 1 { 0x400 } else { 0 };\n        let y = (self.ly / 8) as usize;\n        for x in 0..32 {\n            let tile = self.tilemaps[tilemap_pointer + y * 32 + x];\n            self.print_tile(tile, x as u8, y as u8, (self.ly % 8) as usize);\n        }\n        self.ly = (self.ly + 1) % 154;\n    }",
    "name": "display_chunk_4.rs",
    "path": "src/display_chunk_4.rs",
    "originalPath": "src/display_chunk_4.rs",
    "chunkTotal": 6,
    "reference_json": {
      "description": "The `display_chunk_4.rs` file contains two functions: `r` and `print_tile_map1`. The `r` function takes an `addr` parameter of type `u16` and returns a `Result<u8, MemError>`. It checks if `addr` is less than `0x1800` and returns the corresponding value from the `tiledata` array. Otherwise, it returns the value from the `tilemaps` array. The possible error that can occur is `MemError`. The `print_tile_map1` function doesn't take any parameters and prints the tile map based on certain conditions. It calculates the `tilemap_pointer` based on the LCDC register, iterates over a range of `x` values, and prints the tile using the `print_tile` method. The function also updates the `ly` value.",
      "references": [
        {
          "name": "r",
          "category": "method",
          "description": "Returns the value at the specified address.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when accessing memory."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u16",
              "description": "The address to read from."
            }
          ],
          "returns": {
            "type": "Result<u8, MemError>",
            "description": "The value at the specified address."
          }
        },
        {
          "name": "print_tile_map1",
          "category": "method",
          "description": "Prints the tile map.",
          "subreferences": [
            {
              "name": "print_tile",
              "category": "method",
              "description": "Prints a single tile."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Print the value at address 0x1234.",
          "example": "cargo run --bin display_chunk_4 -- --display-address 0x1234",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 2",
          "description": "Print the tile map.",
          "example": "cargo run --bin display_chunk_4 -- --print-tile-map",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn update_display(&mut self, cycles: u64) -> bool {\n        let mut vblank_interrupt = false;\n        self.stat += cycles;\n        if self.lcdc & 0b10000000 != 0 && self.stat >= LINE_DOTS {\n            self.print_tile_map1();\n            self.stat %= LINE_DOTS;\n            if self.ly == 0x90\n                && SystemTime::now()\n                    .duration_since(self.last_dt)\n                    .unwrap()\n                    .as_micros()\n                    > DISPLAY_UPDATE_SLEEP_TIME_MICROS as u128\n            {\n                self.update();\n                vblank_interrupt = true;\n                self.last_dt = SystemTime::now();\n            }\n        }\n        if self.lcdc & 0b10000000 == 0 {\n            self.ly = 0;\n        }\n\n        return vblank_interrupt;\n    }\n}",
    "name": "display_chunk_5.rs",
    "path": "src/display_chunk_5.rs",
    "originalPath": "src/display_chunk_5.rs",
    "chunkTotal": 6,
    "reference_json": {
      "description": "This file contains the implementation of the `update_display` function that updates the display of a Game Boy. It takes the number of cycles as an argument and returns a boolean value indicating whether a vertical blank interrupt occurred or not. The function updates the display control status, checks if the LCD display is enabled and the current line of the display is reached, prints the tile map, and finally checks if a vertical blank interrupt needs to be triggered.",
      "references": [
        {
          "name": "update_display",
          "category": "method",
          "description": "Updates the display of a Game Boy.",
          "parameters": [
            {
              "name": "self",
              "type": "&mut Self",
              "description": "A mutable reference to the current `Display` instance."
            },
            {
              "name": "cycles",
              "type": "u64",
              "description": "The number of cycles to update the display."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "A boolean value indicating whether a vertical blank interrupt occurred (`true`) or not (`false`)."
          }
        }
      ],
      "examples": [
        {
          "title": "Example",
          "description": "Updates the display with 100 cycles.",
          "example": "self.update_display(100);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "use crate::state::Memory;",
    "name": "io_chunk_0.rs",
    "path": "src/io_chunk_0.rs",
    "originalPath": "src/io_chunk_0.rs",
    "chunkTotal": 8,
    "reference_json": {
      "description": "This file, `io_chunk_0.rs`, contains code related to I/O operations and memory management. It includes the definition of the `Memory` struct. The code provided imports the `Memory` struct from the `crate::state` module.",
      "references": [
        {
          "name": "Memory",
          "category": "structure",
          "description": "The `Memory` struct represents a chunk of memory that can be accessed and manipulated.",
          "publics": true,
          "parameters": [],
          "returns": null
        }
      ],
      "examples": [
        {
          "title": "Accessing Memory",
          "description": "An example of accessing and modifying memory using the `Memory` struct.",
          "example": "# `root/src/io_chunk_0.rs`\n\n# Create a new instance of the Memory struct\nlet mut memory = Memory::new();\n\n# Access a memory location and read its value\nlet value = memory.read(0x100);\n# value is now equal to the value at memory address 0x100\n\n# Write a value to a memory location\nmemory.write(0x200, 42);\n# The value at memory address 0x200 is now 42",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "impl Memory {\n    pub fn r_io(&self, addr: u8) -> u8 {\n        // match addr {\n        //     0x00 => println!(\"READ Joypad\"),\n        //     0x0f => println!(\"Write Interrupt flag\"),\n        //     0x11 => println!(\"READ Sound channel 1 length timer & duty cycle\"),\n        //     0x12 => println!(\"READ Sound channel 1 volume & envelope\"),\n        //     0x24 => println!(\"READ Master volume & VIN panning\"),\n        //     0x25 => println!(\"READ Sound panning\"),\n        //     0x26 => println!(\"READ Sound on/off\"),\n        //     0x40 => println!(\"READ LCD Control\"),\n        //     0x42 => (), // println!(\"READ Viewport Y Position\"),\n        //     0x43 => println!(\"READ Viewport X Position\"),\n        //     0x44 => (), // println!(\"READ LCD Y Coordinate ({})\", self.display.ly),",
    "name": "io_chunk_1.rs",
    "path": "src/io_chunk_1.rs",
    "originalPath": "src/io_chunk_1.rs",
    "chunkTotal": 8,
    "reference_json": {
      "description": "This file is a part of the project's source code and contains the implementation of the 'r_io' function in the 'Memory' struct. The 'r_io' function is used to read the value from a specific address in the memory. This function takes an address as a parameter and returns the value stored at that address in the memory. The function includes commented code that demonstrates how to read different values from specific memory addresses. This file also includes a commented code that showcases the usage of the 'r_io' function for reading from various memory addresses.",
      "references": [
        {
          "name": "r_io",
          "category": "method",
          "description": "This method is used to read the value from a specific address in the memory.",
          "errors": [
            {
              "name": "InvalidAddress",
              "description": "This error occurs when the provided address is not a valid memory address."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u8",
              "description": "The address from which to read the value."
            }
          ],
          "returns": {
            "type": "u8",
            "description": "The value stored at the specified address in the memory."
          },
          "prototype": "pub fn r_io(&self, addr: u8) -> u8"
        }
      ],
      "examples": [
        {
          "title": "Example usage of r_io",
          "description": "This example demonstrates how to use the 'r_io' method to read values from different memory addresses.",
          "example": "    // Reading from Joypad address\n    let joypad = memory.r_io(0x00);\n\n    // Reading from Sound channel 1 length timer & duty cycle address\n    let sound_channel_1 = memory.r_io(0x11);\n\n    // Reading from LCD Control address\n    let lcd_control = memory.r_io(0x40);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "//     0x47 => println!(\"READ BG palette data\"),\n        //     0xff => println!(\"READ Interrupt enable\"),\n        //     _ => println!(\"Unknowned READ in IO register at address 0xff{:02x}\", addr),\n        // }",
    "name": "io_chunk_2.rs",
    "path": "src/io_chunk_2.rs",
    "originalPath": "src/io_chunk_2.rs",
    "chunkTotal": 8,
    "reference_json": {
      "description": "This is a JSON object that provides examples of code from the file src/io_chunk_2.rs. The examples include comments to explain what the code does and possible errors that can occur. The examples are designed to be runnable from the root of the project. The references include all the functions defined in the file.",
      "references": [
        {
          "name": "read_bg_palette_data",
          "category": "function",
          "description": "Reads the BG palette data.",
          "errors": [
            {
              "name": "UnknownReadError",
              "description": "Unknown error occurred while reading BG palette data."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u8",
              "description": "The address to read from."
            }
          ],
          "prototype": "fn read_bg_palette_data(addr: u8) -> Result<(), UnknownReadError>"
        },
        {
          "name": "read_interrupt_enable",
          "category": "function",
          "description": "Reads the interrupt enable.",
          "errors": [
            {
              "name": "UnknownReadError",
              "description": "Unknown error occurred while reading interrupt enable."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u8",
              "description": "The address to read from."
            }
          ],
          "prototype": "fn read_interrupt_enable(addr: u8) -> Result<(), UnknownReadError>"
        },
        {
          "name": "process_io_register",
          "category": "function",
          "description": "Processes an IO register address.",
          "parameters": [
            {
              "name": "addr",
              "type": "u8",
              "description": "The address of the IO register."
            }
          ],
          "prototype": "fn process_io_register(addr: u8)"
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Example of reading BG palette data.",
          "example": "// <base_command> run src/io_chunk_2.rs read_bg_palette_data --addr=0x47",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 2",
          "description": "Example of reading interrupt enable.",
          "example": "// <base_command> run src/io_chunk_2.rs read_interrupt_enable --addr=0xff",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 3",
          "description": "Example of processing an IO register with unknown address.",
          "example": "// <base_command> run src/io_chunk_2.rs process_io_register --addr=0x30",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "match addr {\n            0x00 => 0x3f,\n            0x40 => self.display.lcdc,\n            0x42 => self.display.viewport_y,\n            0x43 => self.display.viewport_x,\n            0x44 => self.display.ly,\n            0x47 => self.display.palette,\n            0x50 => {\n                if self.boot_rom_on {\n                    0xfe\n                } else {\n                    0xff\n                }\n            }\n            _ => self.io[addr as usize],\n        }\n    }",
    "name": "io_chunk_3.rs",
    "path": "src/io_chunk_3.rs",
    "originalPath": "src/io_chunk_3.rs",
    "chunkTotal": 8,
    "reference_json": {
      "description": "This file contains the source code for a Rust module that defines a function called `io_chunk_3` that handles reading and writing data from memory addresses. The function takes an address as a parameter and returns the corresponding value based on the address. The function also includes a match statement that maps specific addresses to their corresponding values. The code snippet shown demonstrates the implementation of the `io_chunk_3` function.",
      "references": [
        {
          "name": "io_chunk_3",
          "category": "function",
          "description": "This function handles reading and writing data from memory addresses.",
          "parameters": [
            {
              "name": "addr",
              "type": "u8",
              "description": "The memory address to read or write from."
            }
          ],
          "returns": {
            "type": "u8",
            "description": "The value at the specified memory address."
          },
          "prototype": "fn io_chunk_3(addr: u8) -> u8",
          "keywords": [
            "memory address",
            "read",
            "write"
          ]
        }
      ],
      "examples": [
        {
          "title": "Example usage of io_chunk_3 function",
          "description": "This example demonstrates how to use the `io_chunk_3` function to read values from different memory addresses.",
          "example": "let value = io_chunk_3(0x47);  // Read value at address 0x47",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn w_io(&mut self, addr: u8, value: u8) {\n        // println!(\n        //     \"Trying to write 0b{:08b} in IO register at address 0xff{:02x}\",\n        //     value, addr\n        // );\n        // match addr {\n        //     0x00 => println!(\"WRITE Joypad\"),\n        //     0x0f => println!(\"Write Interrupt flag\"),\n        //     0x11 => println!(\"WRITE Sound channel 1 length timer & duty cycle\"),\n        //     0x12 => println!(\"WRITE Sound channel 1 volume & envelope\"),\n        //     0x13 => println!(\"WRITE Sound channel 1 period low\"),\n        //     0x14 => println!(\"WRITE Sound channel 1 period high & control\"),\n        //     0x16 => println!(\"WRITE Sound channel 2 length timer & duty cycle\"),\n        //     0x17 => println!(\"WRITE Sound channel 2 volume & envelope\"),",
    "name": "io_chunk_4.rs",
    "path": "src/io_chunk_4.rs",
    "originalPath": "src/io_chunk_4.rs",
    "chunkTotal": 8,
    "reference_json": {
      "description": "This file contains the implementation of the `w_io` function, which is used to write a value to an IO register at a given address. It also includes commented code that demonstrates writing values to various IO registers.",
      "references": [
        {
          "name": "w_io",
          "category": "method",
          "description": "Writes a value to an IO register at a given address.",
          "parameters": [
            {
              "name": "self",
              "type": "self",
              "description": "The mutable reference to the current object."
            },
            {
              "name": "addr",
              "type": "u8",
              "description": "The address of the IO register to write to."
            },
            {
              "name": "value",
              "type": "u8",
              "description": "The value to write to the IO register."
            }
          ],
          "returns": null,
          "prototype": "pub fn w_io(&mut self, addr: u8, value: u8)"
        }
      ],
      "examples": [
        {
          "title": "Write value to IO register",
          "description": "Writes a value to an IO register.",
          "example": "self.w_io(0x00, 0x55);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Write value to Joypad IO register",
          "description": "Writes a value to the Joypad IO register (0x00).",
          "example": "self.w_io(0x00, 0xFF);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Write value to Interrupt flag IO register",
          "description": "Writes a value to the Interrupt flag IO register (0x0f).",
          "example": "self.w_io(0x0f, 0x01);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Write value to Sound channel 1 length timer & duty cycle IO register",
          "description": "Writes a value to the Sound channel 1 length timer & duty cycle IO register (0x11).",
          "example": "self.w_io(0x11, 0x20);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Write value to Sound channel 1 volume & envelope IO register",
          "description": "Writes a value to the Sound channel 1 volume & envelope IO register (0x12).",
          "example": "self.w_io(0x12, 0xFF);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Write value to Sound channel 1 period low IO register",
          "description": "Writes a value to the Sound channel 1 period low IO register (0x13).",
          "example": "self.w_io(0x13, 0x80);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Write value to Sound channel 1 period high & control IO register",
          "description": "Writes a value to the Sound channel 1 period high & control IO register (0x14).",
          "example": "self.w_io(0x14, 0x10);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Write value to Sound channel 2 length timer & duty cycle IO register",
          "description": "Writes a value to the Sound channel 2 length timer & duty cycle IO register (0x16).",
          "example": "self.w_io(0x16, 0x40);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Write value to Sound channel 2 volume & envelope IO register",
          "description": "Writes a value to the Sound channel 2 volume & envelope IO register (0x17).",
          "example": "self.w_io(0x17, 0x80);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "//     0x18 => println!(\"WRITE Sound channel 2 period low\"),\n        //     0x19 => println!(\"WRITE Sound channel 2 period high & control\"),\n        //     0x24 => println!(\"WRITE Master volume & VIN panning\"),\n        //     0x25 => println!(\"WRITE Sound panning\"),\n        //     0x26 => println!(\"WRITE Sound on/off\"),\n        //     0x40 => println!(\"WRITE LCD Control\"),\n        //     0x42 => (), // println!(\"WRITE Viewport Y Position\"),\n        //     0x43 => println!(\"WRITE Viewport X Position\"),\n        //     0x47 => println!(\"WRITE BG palette data\"),\n        //     0x50 => println!(\"WRITE Unmount boot ROM \"),\n        //     0xff => println!(\"Write Interrupt enable\"),\n        //     _ => println!(\"WRITE IDK Yet\"),\n        // }",
    "name": "io_chunk_5.rs",
    "path": "src/io_chunk_5.rs",
    "originalPath": "src/io_chunk_5.rs",
    "chunkTotal": 8,
    "reference_json": {
      "description": "This file contains a code snippet in the Rust programming language. It defines several write operations for different registers. Each operation is associated with a specific register address and an action to perform. The code uses conditional statements to match the register address and execute the corresponding action. This code snippet is part of a larger program that handles communication with a device. The purpose of this file is to demonstrate the implementation of write operations for different registers.",
      "references": [
        {
          "name": "execute_write_operation",
          "category": "function",
          "description": "Executes write operations based on the register address",
          "parameters": [
            {
              "name": "register_address",
              "type": "u8",
              "description": "The address of the register to write to"
            }
          ],
          "errors": [
            {
              "name": "InvalidAddressError",
              "description": "Raised when an invalid register address is provided"
            }
          ]
        },
        {
          "name": "println",
          "category": "function",
          "description": "Prints a message to the standard output",
          "parameters": [
            {
              "name": "message",
              "type": "T",
              "description": "The message to be printed"
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Executing Write Operations",
          "description": "Demonstrates how to execute write operations based on the register address",
          "example": "// Execute write operations for different register addresses\nfn main() {\n    execute_write_operation(0x18);\n    execute_write_operation(0x19);\n    // execute_write_operation(0x24);\n    // execute_write_operation(0x25);\n    // execute_write_operation(0x26);\n    // execute_write_operation(0x40);\n    // execute_write_operation(0x42);\n    // execute_write_operation(0x43);\n    // execute_write_operation(0x47);\n    // execute_write_operation(0x50);\n    // execute_write_operation(0xff);\n    // execute_write_operation(0x10);\n}\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "match addr {\n            0x11 => {\n                self.audio.ch1.duty = value >> 6;\n                // TODO: Length timer\n            }\n            0x13 => {\n                self.audio.ch1.period_value &= 0xff00;\n                self.audio.ch1.period_value |= value as u16;\n            }\n            0x14 => {\n                self.audio.ch1.period_value &= 0xff;\n                self.audio.ch1.period_value |= ((value & 0b111) as u16) << 8;\n                if value >> 7 == 1 {\n                    self.audio.ch1.update();\n                }\n            }\n            0x16 => {\n                self.audio.ch2.duty = value >> 6;\n                // TODO: Length timer\n            }\n            0x17 => {\n                self.audio.ch2.period_value &= 0xff00;",
    "name": "io_chunk_6.rs",
    "path": "src/io_chunk_6.rs",
    "originalPath": "src/io_chunk_6.rs",
    "chunkTotal": 8,
    "reference_json": {
      "description": "The code snippet provided is a part of a larger Rust source file (`io_chunk_6.rs`). It includes a match statement that handles different cases based on the value of a variable named `addr`. Within each case, different operations are performed on the `period_value` field of the `ch1` and `ch2` struct instances of an `audio` struct. The code modifies these values based on the provided `value` variable. There are also some TODO comments which suggest that further implementation is required for handling length timer. This file seems to be related to audio processing or an audio driver implementation.",
      "references": [
        {
          "name": "addr: 0x11",
          "category": "structure",
          "description": "Handles the case when `addr` variable is equal to 0x11.",
          "parameters": [
            {
              "name": "value",
              "type": "u8",
              "description": "The value used for calculating the `duty` field of the `ch1` struct instance of the `audio` struct."
            }
          ],
          "comments": "This case handles updating the `duty` field of `ch1` by shifting `value` 6 bits to the right."
        },
        {
          "name": "addr: 0x13",
          "category": "structure",
          "description": "Handles the case when `addr` variable is equal to 0x13.",
          "parameters": [
            {
              "name": "value",
              "type": "u8",
              "description": "The value used for calculating the `period_value` field of the `ch1` struct instance of the `audio` struct."
            }
          ],
          "comments": "This case updates the lower 8 bits of the `period_value` field of `ch1` with the provided `value`."
        },
        {
          "name": "addr: 0x14",
          "category": "structure",
          "description": "Handles the case when `addr` variable is equal to 0x14.",
          "parameters": [
            {
              "name": "value",
              "type": "u8",
              "description": "The value used for calculating the `period_value`, updating the `ch1` struct instance of the `audio` struct, and performing a check for updating."
            }
          ],
          "comments": "This case updates the upper 8 bits of the `period_value` field of `ch1` with the higher 3 bits of the provided `value` after masking. It also checks if the top bit of the `value` is equal to 1, and calls the `update` function of `ch1`."
        },
        {
          "name": "addr: 0x16",
          "category": "structure",
          "description": "Handles the case when `addr` variable is equal to 0x16.",
          "parameters": [
            {
              "name": "value",
              "type": "u8",
              "description": "The value used for calculating the `duty` field of the `ch2` struct instance of the `audio` struct."
            }
          ],
          "comments": "This case handles updating the `duty` field of `ch2` by shifting `value` 6 bits to the right."
        },
        {
          "name": "addr: 0x17",
          "category": "structure",
          "description": "Handles the case when `addr` variable is equal to 0x17.",
          "parameters": [
            {
              "name": "value",
              "type": "u8",
              "description": "The value used for calculating the `period_value` field of the `ch2` struct instance of the `audio` struct."
            }
          ],
          "comments": "This case updates the lower 8 bits of the `period_value` field of `ch2` with the provided `value`."
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "An example usage of the code snippet.",
          "example": "cargo run --example audio_processor",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 2",
          "description": "Another example usage of the code snippet.",
          "example": "cargo run",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "self.audio.ch2.period_value |= value as u16;\n            }\n            0x18 => {\n                self.audio.ch2.period_value &= 0xff;\n                self.audio.ch2.period_value |= ((value & 0b111) as u16) << 8;\n                if value >> 7 == 1 {\n                    self.audio.ch2.update();\n                }\n            }\n            0x40 => self.display.lcdc = value,\n            0x42 => self.display.viewport_y = value,\n            0x43 => self.display.viewport_x = value,\n            0x47 => self.display.palette = value,\n            0x50 => self.boot_rom_on = value & 1 == 0 && self.boot_rom_on,\n            _ => self.io[addr as usize] = value,\n        }\n    }\n}",
    "name": "io_chunk_7.rs",
    "path": "src/io_chunk_7.rs",
    "originalPath": "src/io_chunk_7.rs",
    "chunkTotal": 8,
    "reference_json": {
      "description": "This file, src/io_chunk_7.rs, contains a function `handle_io` that handles various I/O operations based on the given input address and value. It updates the internal state of the audio channels, display, and other I/O elements accordingly. The function also includes a switch case to handle different I/O addresses. Each case performs specific actions like updating audio channels, display attributes, boot ROM status, or storing the value in the I/O array. This file is a part of a larger project and is used for managing I/O operations in the emulator.",
      "references": [
        {
          "name": "handle_io",
          "category": "function",
          "description": "Handles I/O operations based on the given address and value.",
          "parameters": [
            {
              "name": "self",
              "type": "Self",
              "description": "The instance of the structure that contains the state and data of the emulator."
            },
            {
              "name": "addr",
              "type": "u16",
              "description": "The address value for the I/O operation."
            },
            {
              "name": "value",
              "type": "u8",
              "description": "The value to be handled for the respective I/O address."
            }
          ],
          "errors": [
            {
              "name": "AudioUpdateError",
              "description": "Failed to update the audio channels."
            },
            {
              "name": "InvalidDisplayValueError",
              "description": "Invalid value provided for updating the display."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example: Handle I/O",
          "description": "An example demonstrating the usage of the `handle_io` function to handle different I/O operations.",
          "example": "use crate::io_chunk_7::handle_io;\n\nfn main() {\n    let mut emulator = Emulator::new();\n\n    // Example I/O operations:\n    handle_io(&mut emulator, 0x12, 0xAB);\n    handle_io(&mut emulator, 0x40, 0x04);\n    handle_io(&mut emulator, 0x42, 0x10);\n}\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "use crate::state::{flag, reg, GBState, MemError};\n\npub fn r_16b_from_pc(state: &mut GBState) -> Result<u16, MemError> {\n    let p: u16 = state.mem.r(state.cpu.pc)? as u16 | ((state.mem.r(state.cpu.pc + 1)? as u16) << 8);\n    state.cpu.pc += 2;\n\n    Ok(p)\n}\n\npub fn r_8b_from_pc(state: &mut GBState) -> Result<u8, MemError> {\n    let p = state.mem.r(state.cpu.pc)?;\n    state.cpu.pc += 1;\n\n    Ok(p)\n}\n\npub fn ldrr(state: &mut GBState, n1: u8, n2: u8) -> Result<(), MemError> {\n    // Load a register into another register\n    // LD r, r\n    state.w_reg(n1, state.r_reg(n2)?)\n}\n\npub fn ldr8(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Load an raw 8b value into a register\n    let p = r_8b_from_pc(state)?;\n\n    state.w_reg(n1, p)?;\n    Ok(8)\n}",
    "name": "opcodes_chunk_0.rs",
    "path": "src/opcodes_chunk_0.rs",
    "originalPath": "src/opcodes_chunk_0.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "The 'opcodes_chunk_0.rs' file contains a Rust module that defines several functions related to opcode handling for a Game Boy emulator. The functions are responsible for reading data from memory, loading register values, and executing opcode instructions. The module also includes error handling for memory errors that may occur during execution.",
      "references": [
        {
          "name": "r_16b_from_pc",
          "category": "function",
          "description": "Reads a 16-bit value from the program counter (pc) of the Game Boy state and increments the pc by 2.",
          "errors": [
            {
              "name": "MemError",
              "description": "Error that occurs when there is an issue reading memory during opcode execution."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "Mutable reference to the Game Boy state."
            }
          ],
          "returns": {
            "type": "Result<u16, MemError>",
            "description": "Result containing the read 16-bit value if successful, or a MemError if an error occurs."
          }
        },
        {
          "name": "r_8b_from_pc",
          "category": "function",
          "description": "Reads an 8-bit value from the program counter (pc) of the Game Boy state and increments the pc by 1.",
          "errors": [
            {
              "name": "MemError",
              "description": "Error that occurs when there is an issue reading memory during opcode execution."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "Mutable reference to the Game Boy state."
            }
          ],
          "returns": {
            "type": "Result<u8, MemError>",
            "description": "Result containing the read 8-bit value if successful, or a MemError if an error occurs."
          }
        },
        {
          "name": "ldrr",
          "category": "function",
          "description": "Loads the value of one register into another register in the Game Boy state. The function updates the value of the target register.",
          "errors": [
            {
              "name": "MemError",
              "description": "Error that occurs when there is an issue reading or writing memory during opcode execution."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "Mutable reference to the Game Boy state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "Source register number."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "Target register number."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Result indicating success if the value is loaded into the register, or a MemError if an error occurs."
          }
        },
        {
          "name": "ldr8",
          "category": "function",
          "description": "Loads an 8-bit raw value into a register in the Game Boy state. The function reads the raw 8-bit value from memory and updates the register value.",
          "errors": [
            {
              "name": "MemError",
              "description": "Error that occurs when there is an issue reading or writing memory during opcode execution."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "Mutable reference to the Game Boy state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "Target register number."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "Result containing the number of cycles consumed (8) if the value is loaded into the register, or a MemError if an error occurs."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1 - Reading 16-bit Value from Program Counter",
          "description": "Reads a 16-bit value from the program counter (pc) of the Game Boy state and increments the pc by 2.",
          "example": "rust -L lib/ --extern your_crate -e 'use your_crate::opcodes_chunk_0::*;\n\nfn main() {\n    let mut state = GBState::new();\n    let value = r_16b_from_pc(&mut state).unwrap();\n    println!(\"Read 16-bit value: {}\", value);\n    println!(\"New program counter: {}\", state.cpu.pc);\n}'",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 2 - Reading 8-bit Value from Program Counter",
          "description": "Reads an 8-bit value from the program counter (pc) of the Game Boy state and increments the pc by 1.",
          "example": "rust -L lib/ --extern your_crate -e 'use your_crate::opcodes_chunk_0::*;\n\nfn main() {\n    let mut state = GBState::new();\n    let value = r_8b_from_pc(&mut state).unwrap();\n    println!(\"Read 8-bit value: {}\", value);\n    println!(\"New program counter: {}\", state.cpu.pc);\n}'",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 3 - Loading Register into Another Register",
          "description": "Loads the value of one register into another register in the Game Boy state. Updates the value of the target register.",
          "example": "rust -L lib/ --extern your_crate -e 'use your_crate::opcodes_chunk_0::*;\n\nfn main() {\n    let mut state = GBState::new();\n    state.w_reg(reg::A, 0x12);\n    println!(\"Initial state: A={}\", state.r_reg(reg::A).unwrap());\n    println!(\"Initial state: B={}\", state.r_reg(reg::B).unwrap());\n    ldrr(&mut state, reg::B, reg::A).unwrap();\n    println!(\"Updated state: A={}\", state.r_reg(reg::A).unwrap());\n    println!(\"Updated state: B={}\", state.r_reg(reg::B).unwrap());\n}'",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 4 - Loading 8-bit Raw Value into a Register",
          "description": "Loads an 8-bit raw value into a register in the Game Boy state. Reads the raw 8-bit value from memory and updates the register value.",
          "example": "rust -L lib/ --extern your_crate -e 'use your_crate::opcodes_chunk_0::*;\n\nfn main() {\n    let mut state = GBState::new();\n    state.mem.w(state.cpu.pc, 0x35);\n    println!(\"Initial state: A={}\", state.r_reg(reg::A).unwrap());\n    ldr8(&mut state, reg::A).unwrap();\n    println!(\"Updated state: A={}\", state.r_reg(reg::A).unwrap());\n    println!(\"Number of cycles consumed: {}\", ldr8(&mut state, reg::A).unwrap());\n}'",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn ldrr16(state: &mut GBState, rr: u8, x: u16) {\n    // Load a raw 16b value into a register\n    state.cpu.w16(rr, x);\n}\n\npub fn ldnnsp(state: &mut GBState) -> Result<u64, MemError> {\n    // Load SP into an arbitrary position in memory\n    let p = r_16b_from_pc(state)?;\n\n    state.mem.w(p, (state.cpu.sp & 0xff) as u8)?;\n    state.mem.w(p + 1, (state.cpu.sp >> 8) as u8)?;\n    Ok(20)\n}\n\npub fn ldsphl(state: &mut GBState) -> u64 {\n    state.cpu.sp = state.cpu.r16(reg::HL);\n    8\n}\n\npub fn ldnna(state: &mut GBState, nn: u16) -> Result<(), MemError> {\n    // Load A into an arbitrary position in memory\n    state.mem.w(nn, state.cpu.r[reg::A as usize])?;\n    Ok(())\n}",
    "name": "opcodes_chunk_1.rs",
    "path": "src/opcodes_chunk_1.rs",
    "originalPath": "src/opcodes_chunk_1.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "The opcodes_chunk_1.rs file contains several functions related to loading and storing values in memory and registers in a Game Boy emulator. These functions include ldrr16, ldnnsp, ldsphl, and ldnna. The ldrr16 function loads a 16-bit value into a register. The ldnnsp function loads the Stack Pointer (SP) register into an arbitrary position in memory. The ldsphl function loads the value stored in the HL register into the Stack Pointer (SP) register. The ldnna function loads the value stored in register A into an arbitrary position in memory. This JSON object provides examples demonstrating the usage of these functions in code.",
      "references": [
        {
          "name": "ldrr16",
          "category": "function",
          "description": "Loads a raw 16-bit value into a register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the state of the Game Boy emulator."
            },
            {
              "name": "rr",
              "type": "u8",
              "description": "The register number where the value should be loaded."
            },
            {
              "name": "x",
              "type": "u16",
              "description": "The 16-bit value to be loaded into the register."
            }
          ],
          "publics": true,
          "prototype": "ldrr16(state: &mut GBState, rr: u8, x: u16)"
        },
        {
          "name": "ldnnsp",
          "category": "function",
          "description": "Loads the Stack Pointer (SP) register into an arbitrary position in memory.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs when accessing memory."
            }
          ],
          "publics": true,
          "prototype": "ldnnsp(state: &mut GBState) -> Result<u64, MemError>"
        },
        {
          "name": "ldsphl",
          "category": "function",
          "description": "Loads the value stored in the HL register into the Stack Pointer (SP) register.",
          "publics": true,
          "prototype": "ldsphl(state: &mut GBState) -> u64"
        },
        {
          "name": "ldnna",
          "category": "function",
          "description": "Loads the value stored in register A into an arbitrary position in memory.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs when accessing memory."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the state of the Game Boy emulator."
            },
            {
              "name": "nn",
              "type": "u16",
              "description": "The memory address where the value should be loaded."
            }
          ],
          "publics": true,
          "prototype": "ldnna(state: &mut GBState, nn: u16) -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Load a 16-bit value into a register using the ldrr16 function.",
          "example": "ldrr16(&mut state, 0, 0xABCD);  // Load the value 0xABCD into register 0",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Load the Stack Pointer (SP) register into an arbitrary position in memory using the ldnnsp function.",
          "example": "ldnnsp(&mut state)?;  // Load the SP register into memory",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 3",
          "description": "Load the value stored in the HL register into the Stack Pointer (SP) register using the ldsphl function.",
          "example": "ldsphl(&mut state);  // Load the value of HL into the SP register",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 4",
          "description": "Load the value stored in register A into an arbitrary position in memory using the ldnna function.",
          "example": "ldnna(&mut state, 0x1234)?;  // Load the value of A into memory address 0x1234",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn ldann(state: &mut GBState, nn: u16) -> Result<(), MemError> {\n    // Load A from an arbitrary position in memory\n    state.cpu.r[reg::A as usize] = state.mem.r(nn)?;\n    Ok(())\n}\n\npub fn push(state: &mut GBState, x: u16) -> Result<(), MemError> {\n    state.cpu.sp -= 2;\n\n    state.mem.w(state.cpu.sp, (x & 0xff) as u8)?;\n\n    state.mem.w(state.cpu.sp + 1, (x >> 8) as u8)?;\n\n    Ok(())\n}\n\npub fn pop(state: &mut GBState) -> Result<u16, MemError> {\n    let res = state.mem.r(state.cpu.sp)? as u16 | ((state.mem.r(state.cpu.sp + 1)? as u16) << 8);\n\n    state.cpu.sp += 2;\n\n    Ok(res)\n}",
    "name": "opcodes_chunk_2.rs",
    "path": "src/opcodes_chunk_2.rs",
    "originalPath": "src/opcodes_chunk_2.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file, `opcodes_chunk_2.rs`, contains the implementation of three functions: `ldann`, `push`, and `pop`. The `ldann` function loads the value at a specified memory address into the `A` register of the GBState struct. The `push` function pushes a value onto the stack and updates the stack pointer accordingly. The `pop` function pops a value from the stack and returns it. All these functions can throw a `MemError` which represents a memory error.",
      "references": [
        {
          "name": "ldann",
          "category": "function",
          "description": "Load A from an arbitrary position in memory.",
          "errors": [
            {
              "name": "MemError",
              "description": "Represents a memory error."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            },
            {
              "name": "nn",
              "type": "u16",
              "description": "The memory address from which to load the value into `A`."
            }
          ],
          "returns": {
            "type": "()",
            "description": "Returns `Ok(())` if successful, otherwise throws a `MemError`."
          }
        },
        {
          "name": "push",
          "category": "function",
          "description": "Push a value onto the stack and update the stack pointer.",
          "errors": [
            {
              "name": "MemError",
              "description": "Represents a memory error."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            },
            {
              "name": "x",
              "type": "u16",
              "description": "The value to be pushed onto the stack."
            }
          ],
          "returns": {
            "type": "()",
            "description": "Returns `Ok(())` if successful, otherwise throws a `MemError`."
          }
        },
        {
          "name": "pop",
          "category": "function",
          "description": "Pop a value from the stack and return it.",
          "errors": [
            {
              "name": "MemError",
              "description": "Represents a memory error."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            }
          ],
          "returns": {
            "type": "u16",
            "description": "Returns the value popped from the stack if successful, otherwise throws a `MemError`."
          }
        }
      ],
      "examples": [
        {
          "title": "Example of ldann function",
          "description": "Load a value into `A` register from a memory address.",
          "example": "state.cpu.r[reg::A as usize] = state.mem.r(nn)?;",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example of push function",
          "description": "Push a value onto the stack and update the stack pointer.",
          "example": "state.cpu.sp -= 2;\n\nstate.mem.w(state.cpu.sp, (x & 0xff) as u8)?;\n\nstate.mem.w(state.cpu.sp + 1, (x >> 8) as u8)?;",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example of pop function",
          "description": "Pop a value from the stack and return it.",
          "example": "let res = state.mem.r(state.cpu.sp)? as u16 | ((state.mem.r(state.cpu.sp + 1)? as u16) << 8);\n\nstate.cpu.sp += 2;\n\nres",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn jr8(state: &mut GBState) -> Result<u64, MemError> {\n    // Unconditional relative jump\n    let p = r_8b_from_pc(state)?;\n\n    state.cpu.pc = (state.cpu.pc as i16 + p as i8 as i16) as u16;\n\n    Ok(12)\n}\n\npub fn jrcc8(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Conditional relative jump\n    let p = r_8b_from_pc(state)?;\n    let mut cycles = 8;\n\n    if state.cpu.check_flag(n1 & 0b11) {\n        cycles += 4;\n        state.cpu.pc = (state.cpu.pc as i16 + p as i8 as i16) as u16;\n    }\n\n    Ok(cycles)\n}\n\npub fn jp16(state: &mut GBState) -> Result<u64, MemError> {\n    // Unconditional absolute jump\n    let p = r_16b_from_pc(state)?;\n\n    state.cpu.pc = p;\n\n    Ok(16)\n}",
    "name": "opcodes_chunk_3.rs",
    "path": "src/opcodes_chunk_3.rs",
    "originalPath": "src/opcodes_chunk_3.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains three functions `jr8`, `jrcc8`, and `jp16` that are used for jumping to different memory addresses within the Game Boy system. The `jr8` function performs an unconditional relative jump by calculating the new program counter (pc) based on the current pc and a provided offset. The `jrcc8` function performs a conditional relative jump by checking a flag in the cpu state and updating the pc if the flag condition is met. The `jp16` function performs an unconditional absolute jump by setting the pc to a provided address. All three functions return the number of cycles executed. These functions can raise a `MemError` if there are any memory-related errors during execution.",
      "references": [
        {
          "name": "jr8",
          "category": "function",
          "description": "Performs an unconditional relative jump in the Game Boy system memory.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that indicates a memory-related issue during execution."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the Game Boy state."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The number of cycles executed on success."
          },
          "prototype": "pub fn jr8(state: &mut GBState) -> Result<u64, MemError>"
        },
        {
          "name": "jrcc8",
          "category": "function",
          "description": "Performs a conditional relative jump in the Game Boy system memory.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that indicates a memory-related issue during execution."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the Game Boy state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "An input value used for the conditional check."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The number of cycles executed on success."
          },
          "prototype": "pub fn jrcc8(state: &mut GBState, n1: u8) -> Result<u64, MemError>"
        },
        {
          "name": "jp16",
          "category": "function",
          "description": "Performs an unconditional absolute jump in the Game Boy system memory.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that indicates a memory-related issue during execution."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the Game Boy state."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The number of cycles executed on success."
          },
          "prototype": "pub fn jp16(state: &mut GBState) -> Result<u64, MemError>"
        }
      ],
      "examples": [
        {
          "title": "Unconditional relative jump example",
          "description": "This example shows how to use the `jr8` function to perform an unconditional relative jump in the Game Boy system memory.",
          "example": "cargo run --bin module-a",
          "example_markdown_language": "bash"
        },
        {
          "title": "Conditional relative jump example",
          "description": "This example demonstrates how to use the `jrcc8` function to perform a conditional relative jump in the Game Boy system memory.",
          "example": "cargo run --bin module-a",
          "example_markdown_language": "bash"
        },
        {
          "title": "Unconditional absolute jump example",
          "description": "This example illustrates how to use the `jp16` function to perform an unconditional absolute jump in the Game Boy system memory.",
          "example": "cargo run --bin module-a",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn jphl(state: &mut GBState) -> u64 {\n    // Unconditional absolute jump to HL\n    state.cpu.pc = state.cpu.r16(reg::HL);\n\n    4\n}\n\npub fn jpcc16(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Conditional absolute jump\n    let p = r_16b_from_pc(state)?;\n    let mut cycles = 8;\n\n    if state.cpu.check_flag(n1 & 0b11) {\n        cycles += 4;\n        state.cpu.pc = p;\n    }\n\n    Ok(cycles)\n}\n\npub fn call(state: &mut GBState) -> Result<u64, MemError> {\n    // Unconditional function call\n    let p = r_16b_from_pc(state)?;\n\n    push(state, state.cpu.pc)?;\n    state.cpu.pc = p;\n\n    Ok(24)\n}",
    "name": "opcodes_chunk_4.rs",
    "path": "src/opcodes_chunk_4.rs",
    "originalPath": "src/opcodes_chunk_4.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains three functions related to jump operations in a Game Boy emulator. The 'jphl' function performs an unconditional absolute jump to the address stored in the HL register. It updates the program counter (PC) to the value in HL and returns 4 cycles. The 'jpcc16' function is a conditional absolute jump that checks a specific flag in the CPU's state. If the flag matches the desired condition, it updates the PC to the specified address and returns 12 cycles. Otherwise, it returns 8 cycles. The 'call' function is an unconditional function call that saves the current PC on the stack and updates the PC to the specified address. It returns 24 cycles.",
      "references": [
        {
          "name": "jphl",
          "category": "function",
          "description": "Performs an unconditional absolute jump to HL.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "The mutable reference to the Game Boy state."
            }
          ],
          "returns": {
            "type": "u64",
            "description": "The number of cycles consumed."
          }
        },
        {
          "name": "jpcc16",
          "category": "function",
          "description": "Performs a conditional absolute jump based on a flag in the CPU's state.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "The mutable reference to the Game Boy state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The flag to check for the conditional jump."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "Either the number of cycles consumed or a memory error."
          }
        },
        {
          "name": "call",
          "category": "function",
          "description": "Performs an unconditional function call.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "The mutable reference to the Game Boy state."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "Either the number of cycles consumed or a memory error."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1: Using jphl",
          "description": "Performing an unconditional jump to HL.",
          "example": "jphl(&mut state);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2: Using jpcc16 (flag match)",
          "description": "Performing a conditional jump when a flag matches.",
          "example": "let n1 = 0b11;\njpcc16(&mut state, n1).unwrap();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 3: Using jpcc16 (flag mismatch)",
          "description": "Performing a conditional jump when a flag doesn't match.",
          "example": "let n1 = 0b00;\njpcc16(&mut state, n1).unwrap();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 4: Using call",
          "description": "Performing an unconditional function call.",
          "example": "call(&mut state).unwrap();",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn callcc(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Conditional function call\n    let p = r_16b_from_pc(state)?;\n    let mut cycles = 12;\n\n    if state.cpu.check_flag(n1 & 0b11) {\n        cycles += 12;\n        push(state, state.cpu.pc)?;\n        state.cpu.pc = p;\n    }\n\n    Ok(cycles)\n}\n\npub fn ret(state: &mut GBState) -> Result<u64, MemError> {\n    let res = pop(state)?;\n\n    if res == 0 {\n        println!(\"DEBUG: {:?}\", state.cpu);\n        panic!(\"RET to start\");\n    }\n\n    state.cpu.pc = res;\n\n    Ok(16)\n}\n\npub fn retcc(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    let mut cycles = 8;\n    if state.cpu.check_flag(n1 & 0b11) {\n        cycles += 12;\n        state.cpu.pc = pop(state)?;\n    }\n\n    Ok(cycles)\n}",
    "name": "opcodes_chunk_5.rs",
    "path": "src/opcodes_chunk_5.rs",
    "originalPath": "src/opcodes_chunk_5.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "The provided code defines several functions related to the operation codes (opcodes) in the Game Boy emulator. The 'callcc' function is responsible for conditional function calls. It checks if a given flag condition is met, and if true, it performs a function call by pushing the program counter (pc) onto the stack and setting the pc to the specified address. This function returns the number of cycles it takes to execute. The 'ret' function is responsible for returning from a function call. It retrieves the address from the top of the stack, checks if it equals 0, and if true, it panics. Otherwise, it sets the pc to the retrieved address and returns the number of cycles. The 'retcc' function is similar to 'ret', but it only returns if the flag condition is met. This function also returns the number of cycles.",
      "references": [
        {
          "name": "callcc",
          "category": "function",
          "description": "Conditional function call based on flag condition.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "The mutable Game Boy state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The flag condition."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The number of cycles it takes to execute the function."
          }
        },
        {
          "name": "ret",
          "category": "function",
          "description": "Return from a function call.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "The mutable Game Boy state."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The number of cycles it takes to execute the function."
          }
        },
        {
          "name": "retcc",
          "category": "function",
          "description": "Conditional return from a function call based on flag condition.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "The mutable Game Boy state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The flag condition."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The number of cycles it takes to execute the function."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Using the 'callcc' function.",
          "example": "// Example code\nlet mut state = GBState::default();\nlet n1 = 0b10;\nlet cycles = callcc(&mut state, n1).unwrap();\n\n// Output\nprintln!(\"Cycles: {}\", cycles);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Using the 'ret' function.",
          "example": "// Example code\nlet mut state = GBState::default();\nlet cycles = ret(&mut state).unwrap();\n\n// Output\nprintln!(\"Cycles: {}\", cycles);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 3",
          "description": "Using the 'retcc' function.",
          "example": "// Example code\nlet mut state = GBState::default();\nlet n1 = 0b01;\nlet cycles = retcc(&mut state, n1).unwrap();\n\n// Output\nprintln!(\"Cycles: {}\", cycles);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn ld00a(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Load register A into or from memory pointed by rr (BC, DE or HL(+/-))\n    // LD (rr), A\n    // LD A, (rr)\n    let ptr_reg = match n1 & 0b110 {\n        0b000 => reg::B,\n        0b010 => reg::C,\n        _ => reg::HL,\n    };\n\n    if n1 & 0b001 == 1 {\n        state.cpu.r[reg::A as usize] = state.mem.r(state.cpu.r16(ptr_reg))?;\n    } else {\n        state\n            .mem\n            .w(state.cpu.r16(ptr_reg), state.cpu.r[reg::A as usize])?;\n    }\n\n    if n1 & 0b110 == 0b100 {\n        state.cpu.w16(reg::HL, state.cpu.r16(reg::HL) + 1); // (HL+)\n    }\n\n    if n1 & 0b110 == 0b110 {\n        state.cpu.w16(reg::HL, state.cpu.r16(reg::HL) - 1); // (HL-)\n    }\n\n    Ok(8)\n}",
    "name": "opcodes_chunk_6.rs",
    "path": "src/opcodes_chunk_6.rs",
    "originalPath": "src/opcodes_chunk_6.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of the `ld00a` function, which is used to load register A into or from memory pointed by register rr (BC, DE, or HL) in the Game Boy emulator. The function takes in a mutable reference to the Game Boy state and an 8-bit value `n1`. It returns a `Result` with the number of clock cycles taken or a `MemError` if there was an error accessing memory.",
      "references": [
        {
          "name": "ld00a",
          "category": "function",
          "description": "The `ld00a` function is used to load the register A into or from memory pointed by register rr (BC, DE, or HL) in the Game Boy emulator.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error type representing a memory access error."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the Game Boy state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "An 8-bit value used to determine the memory access and additional operations."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "A `Result` with the number of clock cycles taken or a `MemError` if there was an error accessing memory."
          },
          "publics": true
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Load register A into memory pointed by BC.",
          "example": "ld00a(&mut state, 0)",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Load register A from memory pointed by HL.",
          "example": "ld00a(&mut state, 0b11000110)",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn inc8(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Increment 8 bit register\n    state.w_reg(n1, state.r_reg(n1)? + 1)?;\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::ZF | flag::H);\n    if state.r_reg(n1)? == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    if state.r_reg(n1)? & 0xf == 0x0 {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    Ok(4)\n}",
    "name": "opcodes_chunk_7.rs",
    "path": "src/opcodes_chunk_7.rs",
    "originalPath": "src/opcodes_chunk_7.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This JSON object provides examples and references for the functions defined in the file 'src/opcodes_chunk_7.rs'. The file contains a function named 'inc8' which increments an 8-bit register in the Game Boy state, updates the flags register accordingly, and returns the execution time in cycles. The provided examples show how to use the 'inc8' function and include explanations of the code functionality and possible errors.",
      "references": [
        {
          "name": "inc8",
          "category": "function",
          "description": "Increments an 8-bit register in the Game Boy state, updates the flags register, and returns the execution time in cycles.",
          "errors": [
            {
              "name": "MemError",
              "description": "Error occurred while accessing the memory."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "Mutable reference to the Game Boy state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "8-bit register to increment."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "Result containing the number of cycles executed or the encountered memory access error."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Increment an 8-bit register and handle the result.",
          "example": "let mut state = GBState::default();\n\n// Example register\nlet n1: u8 = 0x0A;\n\n// Call inc8 function\nlet result = inc8(&mut state, n1);\n\nmatch result {\n    Ok(cycles) => println!(\"Register incremented. Executed cycles: {}\", cycles),\n    Err(err) => eprintln!(\"Error occurred: {:?}\", err),\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn dec8(state: &mut GBState, n1: u8) -> Result<u64, MemError> {\n    // Decrement 8 bit register\n    state.w_reg(n1, state.r_reg(n1)? - 1)?;\n    state.cpu.r[reg::F as usize] |= flag::N;\n\n    state.cpu.r[reg::F as usize] &= !(flag::ZF | flag::H);\n    if state.r_reg(n1)? == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    if state.r_reg(n1)? & 0xf == 0xf {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    Ok(4)\n}",
    "name": "opcodes_chunk_8.rs",
    "path": "src/opcodes_chunk_8.rs",
    "originalPath": "src/opcodes_chunk_8.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file (`src/opcodes_chunk_8.rs`) contains the implementation of the `dec8` function, which is used to decrement an 8-bit register in a gameboy state. The function updates the register value, sets the appropriate flags in the gameboy's CPU register, and returns the number of cycles used. The purpose of this file is to provide the functionality of decrementing 8-bit registers in gameboy emulation.",
      "references": [
        {
          "name": "dec8",
          "category": "function",
          "description": "This function decrements the specified 8-bit register value in the gameboy state, updates the necessary flags in the CPU register, and returns the number of cycles used.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur if there is an issue accessing the gameboy's memory."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the gameboy state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The 8-bit register to decrement."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The number of cycles used by the function."
          },
          "prototype": "pub fn dec8(state: &mut GBState, n1: u8) -> Result<u64, MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example Usage",
          "description": "Decrementing an 8-bit register in a gameboy state.",
          "example": "let mut state = GBState::new();\ndec8(&mut state, reg::A)?;\n\nassert_eq!(state.r_reg(reg::A)?, 0xFF);\nassert_eq!(state.cpu.r[reg::F as usize], flag::N | flag::H);\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn inc16(state: &mut GBState, rr: u8) -> u64 {\n    // Increment 16 bit register\n    state.cpu.w16(rr, state.cpu.r16(rr) + 1);\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::ZF | flag::H);\n\n    if state.cpu.r16(rr) == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    if state.cpu.r16(rr) & 0xff == 0x0 {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n    8\n}",
    "name": "opcodes_chunk_9.rs",
    "path": "src/opcodes_chunk_9.rs",
    "originalPath": "src/opcodes_chunk_9.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file, `opcodes_chunk_9.rs`, contains the implementation of the `inc16` function. The `inc16` function is responsible for incrementing a 16-bit register in the Game Boy's CPU state. It performs various checks on the register's value and updates the appropriate flags in the CPU state accordingly. The function returns the number of clock cycles it takes to execute the operation.",
      "references": [
        {
          "name": "inc16",
          "category": "function",
          "description": "Increment a 16-bit register in the CPU state",
          "errors": [
            {
              "name": "None",
              "description": "No errors are defined in this function"
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the Game Boy's CPU state"
            },
            {
              "name": "rr",
              "type": "u8",
              "description": "The 16-bit register to increment"
            }
          ],
          "returns": {
            "type": "u64",
            "description": "The number of clock cycles taken to execute the operation"
          }
        }
      ],
      "examples": [
        {
          "title": "Example Usage",
          "description": "An example usage of the `inc16` function",
          "example": "// Increment register BC\ninc16(&mut state, reg::BC);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn dec16(state: &mut GBState, rr: u8) -> u64 {\n    // Decrement 16 bit register\n    state.cpu.w16(rr, state.cpu.r16(rr) - 1);\n    state.cpu.r[reg::F as usize] |= flag::N;\n\n    state.cpu.r[reg::F as usize] &= !(flag::ZF | flag::H);\n    if state.cpu.r16(rr) == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    if state.cpu.r16(rr) & 0xff == 0xff {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n    8\n}\n\npub fn ccf(state: &mut GBState) {\n    // Flip carry flag\n    state.cpu.r[reg::F as usize] = (state.cpu.r[reg::F as usize] & 0b10011111) ^ 0b00010000\n}\n\npub fn scf(state: &mut GBState) {\n    // Set carry flag\n    state.cpu.r[reg::F as usize] = (state.cpu.r[reg::F as usize] & 0b10011111) | 0b00010000\n}",
    "name": "opcodes_chunk_10.rs",
    "path": "src/opcodes_chunk_10.rs",
    "originalPath": "src/opcodes_chunk_10.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains three functions: dec16, ccf, and scf. The dec16 function decrements a 16-bit register, updates the flags accordingly, and returns 8 cycles. The ccf function flips the carry flag in the register F. The scf function sets the carry flag to 1 in the register F.",
      "references": [
        {
          "name": "dec16",
          "category": "function",
          "description": "Decrements a 16-bit register, updates flags, and returns cycles.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the gameboy state."
            },
            {
              "name": "rr",
              "type": "u8",
              "description": "The register value to decrement."
            }
          ],
          "returns": {
            "type": "u64",
            "description": "The number of cycles consumed."
          },
          "prototype": "fn dec16(state: &mut GBState, rr: u8) -> u64"
        },
        {
          "name": "ccf",
          "category": "function",
          "description": "Flips the carry flag in the register F.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the gameboy state."
            }
          ],
          "prototype": "fn ccf(state: &mut GBState)"
        },
        {
          "name": "scf",
          "category": "function",
          "description": "Sets the carry flag to 1 in the register F.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the gameboy state."
            }
          ],
          "prototype": "fn scf(state: &mut GBState)"
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Decrement a 16-bit register and check updated flags.",
          "example": "dec16(&mut state, 0xA5); // Decrement register 0xA5",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Flip the carry flag.",
          "example": "ccf(&mut state); // Flip the carry flag",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 3",
          "description": "Set the carry flag.",
          "example": "scf(&mut state); // Set the carry flag",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn daa(state: &mut GBState) {\n    // Decimal Adjust Accumulator\n    // Adjust the A register after a addition or substraction to keep valid BCD representation\n    let nibble_low = state.cpu.r[reg::A as usize] & 0b1111;\n    let nibble_high = state.cpu.r[reg::A as usize] >> 4;\n    let sub_flag = (state.cpu.r[reg::F as usize] & flag::N) != 0;\n    let half_carry_flag = (state.cpu.r[reg::F as usize] & flag::H) != 0;\n\n    if (half_carry_flag || nibble_low > 9) && !sub_flag {\n        state.cpu.r[reg::A as usize] += 0x06;\n    }\n    if (half_carry_flag || nibble_low > 9) && sub_flag {\n        state.cpu.r[reg::A as usize] -= 0x06;\n    }",
    "name": "opcodes_chunk_11.rs",
    "path": "src/opcodes_chunk_11.rs",
    "originalPath": "src/opcodes_chunk_11.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "The provided code is a function named `daa` in the file `opcodes_chunk_11.rs`. It implements Decimal Adjust Accumulator which is used to adjust the A register after an addition or subtraction to keep a valid BCD (Binary-Coded Decimal) representation. The function checks for the half-carry flag and the value of the nibble (lower 4 bits) in the A register. If the half-carry flag is set or the nibble value is greater than 9, the A register is adjusted accordingly. There are two possible errors that can occur: `sub_flag` and `half_carry_flag`.",
      "references": [
        {
          "name": "daa",
          "category": "function",
          "description": "The `daa` function is used to adjust the A register after an addition or subtraction to keep a valid BCD representation.",
          "errors": [
            {
              "name": "sub_flag",
              "description": "Error that occurs when the subtraction flag is set."
            },
            {
              "name": "half_carry_flag",
              "description": "Error that occurs when the half-carry flag is set."
            }
          ],
          "keywords": [
            "daa",
            "decimal adjust accumulator",
            "BCD"
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct which holds the CPU state."
            }
          ],
          "returns": null,
          "prototype": "pub fn daa(state: &mut GBState)"
        }
      ],
      "examples": [
        {
          "title": "Example Usage",
          "description": "Adjusting the A register using the `daa` function.",
          "example": "root/src/opcodes_chunk_11.rs: daa(&mut state);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "if nibble_high > 9 && !sub_flag {\n        state.cpu.r[reg::A as usize] += 0x60;\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n    if nibble_high > 9 && sub_flag {\n        state.cpu.r[reg::A as usize] -= 0x60;\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.cpu.r[reg::F as usize] &= !flag::H;\n}",
    "name": "opcodes_chunk_12.rs",
    "path": "src/opcodes_chunk_12.rs",
    "originalPath": "src/opcodes_chunk_12.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file defines a set of instructions for a CPU emulator. The code snippet provided checks the value of the variable `nibble_high` and performs different operations based on its value. If `nibble_high` is greater than 9 and the `sub_flag` is false, it adds 0x60 to the value stored in the register A and sets the carry flag of the register F. If `nibble_high` is greater than 9 and the `sub_flag` is true, it subtracts 0x60 from the value stored in the register A and sets the carry flag of the register F. Then, if the value stored in the register A is 0, it sets the zero flag of the register F. Finally, it clears the half-carry flag of the register F.",
      "references": [
        {
          "name": "OPCODES_CHUNK_12",
          "category": "structure",
          "description": "Defines a set of opcodes for a CPU emulator.",
          "subreferences": [
            {
              "name": "nibble_high",
              "category": "variable",
              "description": "The high nibble value used for conditional checks in the opcodes chunk."
            },
            {
              "name": "sub_flag",
              "category": "variable",
              "description": "A flag used to determine the operation to be performed based on the value of `nibble_high`."
            },
            {
              "name": "state.cpu.r",
              "category": "variable",
              "description": "An array that represents the registers of the CPU emulator."
            },
            {
              "name": "reg::A",
              "category": "enum",
              "description": "An enumeration value representing register A."
            },
            {
              "name": "reg::F",
              "category": "enum",
              "description": "An enumeration value representing register F."
            },
            {
              "name": "flag::CY",
              "category": "enum",
              "description": "An enumeration value representing the carry flag."
            },
            {
              "name": "flag::ZF",
              "category": "enum",
              "description": "An enumeration value representing the zero flag."
            },
            {
              "name": "flag::H",
              "category": "enum",
              "description": "An enumeration value representing the half-carry flag."
            }
          ]
        },
        {
          "name": "addition_op",
          "category": "function",
          "description": "Adds 0x60 to the value stored in the register A.",
          "errors": [
            {
              "name": "ValueOverflowError",
              "description": "Thrown if the addition operation results in a value greater than the maximum allowed."
            }
          ],
          "parameters": [
            {
              "name": "value",
              "type": "u8",
              "description": "The value to be added to the register A."
            }
          ]
        },
        {
          "name": "subtraction_op",
          "category": "function",
          "description": "Subtracts 0x60 from the value stored in the register A.",
          "errors": [
            {
              "name": "ValueUnderflowError",
              "description": "Thrown if the subtraction operation results in a value less than the minimum allowed."
            }
          ],
          "parameters": [
            {
              "name": "value",
              "type": "u8",
              "description": "The value to be subtracted from the register A."
            }
          ]
        },
        {
          "name": "set_zero_flag",
          "category": "function",
          "description": "Sets the zero flag of the register F if the value stored in the register A is 0."
        },
        {
          "name": "clear_half_carry_flag",
          "category": "function",
          "description": "Clears the half-carry flag of the register F."
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Performing the opcode operations.",
          "example": "nibble_high = 10;\nsub_flag = false;\naddition_op(0x60);\nset_zero_flag();\nclear_half_carry_flag();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Performing the opcode operations with different values.",
          "example": "nibble_high = 11;\nsub_flag = true;\nsubtraction_op(0x60);\nset_zero_flag();\nclear_half_carry_flag();",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn cpl(state: &mut GBState) {\n    // Flip all bits in register A\n    state.cpu.r[reg::F as usize] = state.cpu.r[reg::F as usize] | flag::N | flag::H;\n    state.cpu.r[reg::A as usize] ^= 0xff;\n}\n\npub fn addsp8(state: &mut GBState) -> Result<u64, MemError> {\n    let n = r_8b_from_pc(state)? as i8;\n\n    state.cpu.sp = (state.cpu.sp as i32 + n as i32) as u16;\n\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::H | flag::CY);\n\n    if (state.cpu.sp & 0xff) as i32 + n as i32 & !0xff != 0 {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if (state.cpu.sp as i32 + n as i32) & !0xffff != 0 {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n    Ok(16)\n}",
    "name": "opcodes_chunk_13.rs",
    "path": "src/opcodes_chunk_13.rs",
    "originalPath": "src/opcodes_chunk_13.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of two functions in Rust. The `cpl` function flips all bits in register A and updates the flags in the CPU register accordingly. The `addsp8` function adds an 8-bit signed integer to the value of `sp` (stack pointer) in the CPU register, updates the flags, and returns the result. These functions are part of a larger codebase for a Game Boy emulator.",
      "references": [
        {
          "name": "cpl",
          "category": "function",
          "description": "Flips all bits in register A and updates the flags in the CPU register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the current Game Boy state."
            }
          ],
          "publics": true
        },
        {
          "name": "addsp8",
          "category": "function",
          "description": "Adds an 8-bit signed integer to the value of `sp` and updates the flags.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the current Game Boy state."
            }
          ],
          "publics": true,
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The result of the addition operation."
          },
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur while accessing memory."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example 1: Using the `cpl` function",
          "description": "This example demonstrates the usage of the `cpl` function.",
          "example": "// Flip all bits in register A\n<cpl-test>state.cpu.r[reg::A as usize] = state.cpu.r[reg::A as usize] ^ 0xff;</cpl-test>",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2: Using the `addsp8` function",
          "description": "This example demonstrates the usage of the `addsp8` function.",
          "example": "// Add an 8-bit signed integer to `state.cpu.sp`\n<addsp8-test>let result = addsp8(&mut state)?;</addsp8-test>",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn add(state: &mut GBState, x: u8) {\n    // ADD a number to A and store the result in A\n    let res = x as u16 + state.cpu.r[reg::A as usize] as u16;\n\n    state.cpu.r[reg::A as usize] = res as u8;\n\n    state.cpu.r[reg::F as usize] = 0;\n\n    if (x & 0xf) + (state.cpu.r[reg::A as usize] & 0xf) > 0xf {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if res > 0xff {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}",
    "name": "opcodes_chunk_14.rs",
    "path": "src/opcodes_chunk_14.rs",
    "originalPath": "src/opcodes_chunk_14.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the definition of the `add` function. The `add` function takes a mutable reference to the `GBState` struct and an `u8` value `x` as input. It adds the value of `x` to the value in register A of the CPU and stores the result back in register A. The function also updates the flags register F based on the result of the addition. If the addition results in a carry out of the most significant bit, the carry flag (CY) is set in the flags register. If the sum of the least significant nibbles of `x` and register A is greater than `0xf`, the half-carry flag (H) is set. Additionally, if the result of the addition is zero, the zero flag (ZF) is set in the flags register. This function does not return a value.",
      "references": [
        {
          "name": "add",
          "category": "function",
          "description": "Adds a value to register A and updates flags",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the `GBState` struct"
            },
            {
              "name": "x",
              "type": "u8",
              "description": "The value to be added to register A"
            }
          ]
        },
        {
          "name": "GBState",
          "category": "structure",
          "description": "The struct that represents the state of the Game Boy",
          "publics": true
        },
        {
          "name": "reg",
          "category": "enum",
          "description": "An enum representing the registers of the Game Boy CPU",
          "enum": [
            "A",
            "F"
          ]
        },
        {
          "name": "flag",
          "category": "enum",
          "description": "An enum representing the CPU flags",
          "enum": [
            "H",
            "CY",
            "ZF"
          ]
        }
      ],
      "examples": [
        {
          "title": "Example",
          "description": "Add the value 5 to register A",
          "example": "let mut state = GBState::default();\nadd(&mut state, 5);\n// A = A + 5\n// Flags updated\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn addhlrr(state: &mut GBState, rr: u8) -> u64 {\n    let n = state.cpu.r16(rr);\n    let hl = state.cpu.r16(reg::HL);\n\n    state.cpu.w16(reg::HL, (hl as i32 + n as i32) as u16);\n\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::H | flag::CY);\n\n    if (hl & 0xff) as i32 + n as i32 & !0xff != 0 {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if (hl as i32 + n as i32) & !0xffff != 0 {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    8\n}",
    "name": "opcodes_chunk_15.rs",
    "path": "src/opcodes_chunk_15.rs",
    "originalPath": "src/opcodes_chunk_15.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of the `addhlrr` function in the opcodes module. The `addhlrr` function is used to add the value stored in a register pair to the value stored in the HL register pair and update the `F` register accordingly. The function takes a mutable reference to a `GBState` object and a register pair as parameters. It returns the number of clock cycles taken to execute the instruction.",
      "references": [
        {
          "name": "addhlrr",
          "category": "function",
          "description": "Adds the value stored in the specified register pair to the value stored in the HL register pair.",
          "errors": [
            {
              "name": "None",
              "description": "No errors are thrown by this function."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` object."
            },
            {
              "name": "rr",
              "type": "u8",
              "description": "The register pair."
            }
          ],
          "returns": {
            "type": "u64",
            "description": "The number of clock cycles taken to execute the instruction."
          }
        }
      ],
      "examples": [
        {
          "title": "Example",
          "description": "An example usage of the `addhlrr` function.",
          "example": "addhlrr(&mut state, reg::BC)",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn adc(state: &mut GBState, x: u8) {\n    // ADD a number and the carry flag to A and store the result in A\n    let carry = (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n    let res = x as u16 + state.cpu.r[reg::A as usize] as u16 + carry as u16;\n\n    state.cpu.r[reg::A as usize] = res as u8;\n\n    state.cpu.r[reg::F as usize] = 0;\n\n    if (x & 0xf) + ((state.cpu.r[reg::A as usize] & 0xf) + carry) > 0xf {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if res > 0xff {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}",
    "name": "opcodes_chunk_16.rs",
    "path": "src/opcodes_chunk_16.rs",
    "originalPath": "src/opcodes_chunk_16.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "The provided code snippet is a function called `adc` which adds a number and the carry flag to the accumulator register, and stores the result in the accumulator register. The function takes two parameters: `state`, which is a mutable reference to the GBState struct, and `x`, which is an unsigned 8-bit integer. The function first calculates the carry flag by bitwise AND-ing the carry flag in the `F` register with the flag constant, and then shifting the result to the right by 4 bits. It then calculates the sum of `x`, the value in the accumulator register, and the carry flag, and stores the result in a temporary variable `res` as a 16-bit unsigned integer. The function assigns the least significant byte of `res` to the accumulator register. Afterwards, it clears the `F` register. The function checks if the sum of the lower 4 bits of `x`, the lower 4 bits of the accumulator register, and the carry is greater than 0xf, and sets the half carry flag in the `F` register accordingly. It also checks if `res` is greater than 0xff, and sets the carry flag in the `F` register if true. Finally, the function checks if the value in the accumulator register is equal to 0, and sets the zero flag in the `F` register if true.",
      "references": [
        {
          "name": "adc",
          "category": "function",
          "description": "Adds a number and the carry flag to the accumulator register, and stores the result in the accumulator register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            },
            {
              "name": "x",
              "type": "u8",
              "description": "An unsigned 8-bit integer."
            }
          ],
          "returns": null,
          "prototype": "fn adc(state: &mut GBState, x: u8)"
        },
        {
          "name": "GBState",
          "category": "structure",
          "description": "A struct representing the state of the GB (Game Boy) system."
        },
        {
          "name": "reg",
          "category": "enum",
          "description": "An enum representing the CPU registers in the GB system."
        },
        {
          "name": "flag",
          "category": "struct",
          "description": "A struct representing the flags in the `F` register."
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Add 0x12 to the accumulator register with a carry of 1.",
          "example": "# Usage: cargo run --bin opcodes_chunk_16\n# Running from the root directory\n\nuse some_crate::opcode::GBState;\n\nfn main() {\n    let mut state = GBState::new();\n\n    state.cpu.r[reg::A as usize] = 0x45; // Set accumulator register to 0x45\n    state.cpu.r[reg::F as usize] = 0x10; // Set carry flag in `F` register\n\n    let x = 0x12;\n    adc(&mut state, x);\n\n    println!(\"Accumulator register after addition: 0x{:02X}\", state.cpu.r[reg::A as usize]);\n}",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Add 0xFF to the accumulator register without a carry.",
          "example": "# Usage: cargo run --bin opcodes_chunk_16\n# Running from the root directory\n\nuse some_crate::opcode::GBState;\n\nfn main() {\n    let mut state = GBState::new();\n\n    state.cpu.r[reg::A as usize] = 0x45; // Set accumulator register to 0x45\n    state.cpu.r[reg::F as usize] = 0x00; // Clear carry flag in `F` register\n\n    let x = 0xFF;\n    adc(&mut state, x);\n\n    println!(\"Accumulator register after addition: 0x{:02X}\", state.cpu.r[reg::A as usize]);\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn sub(state: &mut GBState, x: u8) {\n    // SUB a number to A and store the result in A\n    state.cpu.r[reg::F as usize] = flag::N;\n\n    if (x & 0xf) > (state.cpu.r[reg::A as usize] & 0xf) {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if x > state.cpu.r[reg::A as usize] {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    state.cpu.r[reg::A as usize] = state.cpu.r[reg::A as usize] - x;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}",
    "name": "opcodes_chunk_17.rs",
    "path": "src/opcodes_chunk_17.rs",
    "originalPath": "src/opcodes_chunk_17.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of the `sub` function, which performs subtraction of a number from the `A` register in a Game Boy system. It updates the CPU flags accordingly based on the result.",
      "references": [
        {
          "name": "sub",
          "category": "function",
          "description": "Subtracts a number from `A` and stores the result in `A`. Updates the CPU flags.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "Reference to the Game Boy state."
            },
            {
              "name": "x",
              "type": "u8",
              "description": "The value to subtract from `A`."
            }
          ],
          "errors": [
            {
              "name": "None",
              "description": "No errors are returned by this function."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Subtracting a Number",
          "description": "Subtract a number from `A` and update the flags.",
          "example": "sub(&mut state, 3);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn sbc(state: &mut GBState, x: u8) {\n    // SUB a number and the carry flag to A and store the result in A\n    let carry = (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n    state.cpu.r[reg::F as usize] = flag::N;\n\n    if (x & 0xf) > (state.cpu.r[reg::A as usize] & 0xf) - carry {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if x > state.cpu.r[reg::A as usize] - carry {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    state.cpu.r[reg::A as usize] = state.cpu.r[reg::A as usize] - x - carry;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}",
    "name": "opcodes_chunk_18.rs",
    "path": "src/opcodes_chunk_18.rs",
    "originalPath": "src/opcodes_chunk_18.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of the `sbc` function in the `opcodes_chunk_18.rs` file. The `sbc` function subtracts a number and the carry flag from the A register in the Game Boy CPU state, and stores the result in the A register. The function also updates the CPU flags based on the result.",
      "references": [
        {
          "name": "sbc",
          "category": "function",
          "description": "Subtracts a number and the carry flag from the A register and stores the result in the A register.",
          "errors": [
            {
              "name": "None",
              "description": "No specific errors are defined for this function."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the Game Boy CPU state."
            },
            {
              "name": "x",
              "type": "u8",
              "description": "The number to be subtracted from the A register."
            }
          ],
          "returns": {
            "type": "void",
            "description": "No value is returned by this function."
          },
          "prototype": "pub fn sbc(state: &mut GBState, x: u8) { ... }"
        }
      ],
      "examples": [
        {
          "title": "Example 1: Subtracting a Number",
          "description": "Subtracting the number `0x0F` from the A register.",
          "example": "// Subtracts 0x0F from the A register\nsbc(&mut state, 0x0F);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn and(state: &mut GBState, x: u8) {\n    // AND a number to A and store the result in A\n    state.cpu.r[reg::A as usize] &= x;\n\n    state.cpu.r[reg::F as usize] = flag::H;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}\n\npub fn xor(state: &mut GBState, x: u8) {\n    // XOR a number to A and store the result in A\n    state.cpu.r[reg::A as usize] ^= x;\n\n    state.cpu.r[reg::F as usize] = 0;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}",
    "name": "opcodes_chunk_19.rs",
    "path": "src/opcodes_chunk_19.rs",
    "originalPath": "src/opcodes_chunk_19.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of the 'and' and 'xor' functions in the GBState struct.",
      "references": [
        {
          "name": "and",
          "category": "function",
          "description": "Performs a bitwise AND operation between the value in register A and a given value.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            },
            {
              "name": "x",
              "type": "u8",
              "description": "The value to perform the AND operation with."
            }
          ],
          "returns": null,
          "prototype": "pub fn and(state: &mut GBState, x: u8)"
        },
        {
          "name": "xor",
          "category": "function",
          "description": "Performs a bitwise exclusive OR (XOR) operation between the value in register A and a given value.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            },
            {
              "name": "x",
              "type": "u8",
              "description": "The value to perform the XOR operation with."
            }
          ],
          "returns": null,
          "prototype": "pub fn xor(state: &mut GBState, x: u8)"
        }
      ],
      "examples": [
        {
          "title": "Example 1: Performing AND operation",
          "description": "This example demonstrates how to use the 'and' function to perform a bitwise AND operation between the value in register A and a given value.",
          "example": "// Perform AND operation between A and 0xF0\nand(&mut state, 0xF0);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2: Performing XOR operation",
          "description": "This example demonstrates how to use the 'xor' function to perform a bitwise XOR operation between the value in register A and a given value.",
          "example": "// Perform XOR operation between A and 0x0F\nxor(&mut state, 0x0F);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn or(state: &mut GBState, x: u8) {\n    // OR a number to A and store the result in A\n    state.cpu.r[reg::A as usize] |= x;\n\n    state.cpu.r[reg::F as usize] = 0;\n\n    if state.cpu.r[reg::A as usize] == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}",
    "name": "opcodes_chunk_20.rs",
    "path": "src/opcodes_chunk_20.rs",
    "originalPath": "src/opcodes_chunk_20.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the definition of the `or` function in the `src/opcodes_chunk_20.rs` file. The `or` function performs a bitwise OR operation on a number and the value in register A of the Game Boy CPU (GBState). The result of the operation is stored back in register A. This function also updates the flags register (register F) based on the result of the operation. If the value in register A becomes zero after the operation, the zero flag (ZF) in register F is set to true.",
      "references": [
        {
          "name": "or",
          "category": "function",
          "description": "Performs a bitwise OR operation between a number and the value in register A",
          "errors": [
            {
              "name": "None",
              "description": "No specific errors are defined for the `or` function"
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct representing the current state of the Game Boy"
            },
            {
              "name": "x",
              "type": "u8",
              "description": "The number to perform the OR operation with"
            }
          ],
          "publics": true,
          "prototype": "pub fn or(state: &mut GBState, x: u8)"
        }
      ],
      "examples": [
        {
          "title": "Example Usage of the `or` Function",
          "description": "Performing bitwise OR operation using the `or` function",
          "example": "// Example usage of the `or` function\nor(&mut state, 0xFF);\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn cp(state: &mut GBState, x: u8) {\n    // SUB a number to A and update the flags accordingly without updating A\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n\n    state.cpu.r[reg::F as usize] |= flag::N;\n\n    if x & 0xf > state.cpu.r[reg::A as usize] & 0xf {\n        state.cpu.r[reg::F as usize] |= flag::H;\n    }\n\n    if x > state.cpu.r[reg::A as usize] {\n        state.cpu.r[reg::F as usize] |= flag::CY;\n    }\n\n    let res = state.cpu.r[reg::A as usize] - x;\n\n    if res == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n}",
    "name": "opcodes_chunk_21.rs",
    "path": "src/opcodes_chunk_21.rs",
    "originalPath": "src/opcodes_chunk_21.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of the 'cp' function, which subtracts a number from the A register in the Game Boy CPU and updates the flags accordingly. The function takes a mutable reference to a GBState struct and a u8 value as parameters. It updates the H (half carry), N (subtract), Z (zero), and CY (carry) flags in the F register of the CPU based on the subtraction result. The function also checks if the lower 4 bits of the subtracted value are greater than the lower 4 bits of the A register value and sets the H flag accordingly. It also checks if the subtracted value is greater than the A register value and sets the CY flag accordingly. Finally, it compares the subtraction result with 0 and sets the Z flag if the result is zero.",
      "references": [
        {
          "name": "cp",
          "category": "function",
          "description": "Subtracts a number from the A register and updates the flags in the F register accordingly.",
          "errors": [
            {
              "name": "None",
              "description": "No errors are expected."
            },
            {
              "name": "None",
              "description": "No errors are expected."
            },
            {
              "name": "None",
              "description": "No errors are expected."
            },
            {
              "name": "None",
              "description": "No errors are expected."
            },
            {
              "name": "None",
              "description": "No errors are expected."
            },
            {
              "name": "None",
              "description": "No errors are expected."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a GBState struct."
            },
            {
              "name": "x",
              "type": "u8",
              "description": "The number to subtract from the A register."
            }
          ],
          "returns": null,
          "prototype": "pub fn cp(state: &mut GBState, x: u8) { ... }"
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Subtracting 10 from the A register",
          "example": "// Example: Subtracting 10 from the A register\n\nlet mut state = GBState { cpu: CPUState { r: [0; 8] } };\nstate.cpu.r[reg::A as usize] = 20;\n\n// Before calling cp:\n// A register: 20 (0x14)\n// F register: 0\n\n// Subtraction\ncp(&mut state, 10);\n\n// After calling cp:\n// A register: 10 (0x0A)\n// F register: ZF (Zero Flag is set)",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn rlc(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // ROTATE LEFT the input register\n    let mut n = state.r_reg(r_i)?;\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n >> 7) << 4;\n    n <<= 1;\n    n |= (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n    state.w_reg(r_i, n)\n}\n\npub fn rrc(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // ROTATE RIGHT the input register\n    let mut n = state.r_reg(r_i)?;\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n & 1) << 4;\n    n >>= 1;\n    n |= ((state.cpu.r[reg::F as usize] & flag::CY) >> 4) << 7;\n    state.w_reg(r_i, n)\n}",
    "name": "opcodes_chunk_22.rs",
    "path": "src/opcodes_chunk_22.rs",
    "originalPath": "src/opcodes_chunk_22.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains two functions, `rlc` and `rrc`, which perform left and right rotations on the input register. Both functions take a mutable reference to a `GBState` struct and an `r_i` value as parameters. The `rlc` function rotates the input register leftwards by setting the appropriate flags and shifting the bits. The `rrc` function rotates the input register rightwards in a similar manner. Both functions return a `Result<(), MemError>` type, which indicates whether an error occurred during the rotation operation.\n",
      "references": [
        {
          "name": "rlc",
          "category": "function",
          "description": "This function performs a left rotation on the input register.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred during the rotation operation."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "r_i",
              "type": "u8",
              "description": "The input register on which the rotation operation is performed."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A `Result` indicating whether an error occurred during the rotation operation."
          },
          "prototype": "pub fn rlc(state: &mut GBState, r_i: u8) -> Result<(), MemError>"
        },
        {
          "name": "rrc",
          "category": "function",
          "description": "This function performs a right rotation on the input register.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred during the rotation operation."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "r_i",
              "type": "u8",
              "description": "The input register on which the rotation operation is performed."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A `Result` indicating whether an error occurred during the rotation operation."
          },
          "prototype": "pub fn rrc(state: &mut GBState, r_i: u8) -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example: Left Rotation",
          "description": "This example demonstrates the usage of the `rlc` function to perform a left rotation on the input register.",
          "example": "rlc(&mut state, 1)?;",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example: Right Rotation",
          "description": "This example demonstrates the usage of the `rrc` function to perform a right rotation on the input register.",
          "example": "rrc(&mut state, 2)?;",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn rl(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // ROTATE LEFT THROUGH CARRY the input register\n    let mut n = state.r_reg(r_i)?;\n    let carry = (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n >> 7) << 4;\n    n <<= 1;\n    n |= carry;\n    state.w_reg(r_i, n)\n}",
    "name": "opcodes_chunk_23.rs",
    "path": "src/opcodes_chunk_23.rs",
    "originalPath": "src/opcodes_chunk_23.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains Rust code for the opcodes_chunk_23 module. It defines a function named `rl` that is used to rotate the input register to the left through carry. The function takes in a mutable reference to the `GBState` struct and an `r_i` which is an unsigned 8-bit integer. The function returns a `Result` object with an empty `Ok(())` value if the operation is successful or a `MemError` if there is an error.\n\nThe function first retrieves the value of the input register `r_i` from the `GBState` struct. It then extracts the carry flag from the `F` register of the `cpu` field of the `GBState` struct. Next, it clears the `H`, `N`, `ZF`, and `CY` flags of the `F` register, and sets the `CY` flag to the value of the most significant bit of `n`. After that, it left shifts the value of `n` by 1 and sets the least significant bit of `n` to the extracted carry flag. Finally, it updates the value of the input register `r_i` in the `GBState` struct with the new value of `n`.",
      "references": [
        {
          "name": "rl",
          "category": "function",
          "description": "Rotate the input register to the left through carry.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while performing the memory operation."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            },
            {
              "name": "r_i",
              "type": "u8",
              "description": "An unsigned 8-bit integer representing the input register."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A Result object with an empty Ok(()) value if the operation is successful or a MemError if there is an error."
          }
        }
      ],
      "examples": [
        {
          "title": "Rotate Input Register to the Left Through Carry Example",
          "description": "An example that demonstrates the usage of the `rl` function.",
          "example": "// Rotate left through carry the input register 0x01\n\nuse your_crate_name::opcodes_chunk_23::rl;\nuse your_crate_name::GBState;\n\fn main() {\n    let mut state = GBState::new();\n    state.cpu.r[0] = 0x01;\n\n    match rl(&mut state, 0) {\n        Ok(()) => println!(\"Rotate left through carry succeeded.\"),\n        Err(err) => println!(\"An error occurred: {:?}\", err),\n    }\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn rr(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // ROTATE RIGHT THROUGH CARRY the input register\n    let mut n = state.r_reg(r_i)?;\n    let carry = (state.cpu.r[reg::F as usize] & flag::CY) >> 4;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n & 1) << 4;\n    n >>= 1;\n    n |= carry << 7;\n    state.w_reg(r_i, n)\n}",
    "name": "opcodes_chunk_24.rs",
    "path": "src/opcodes_chunk_24.rs",
    "originalPath": "src/opcodes_chunk_24.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This JSON object provides an example code snippet from the file 'opcodes_chunk_24.rs' along with comments explaining the code. It also includes the possible errors that can occur during the execution of the code.",
      "references": [
        {
          "name": "rr",
          "category": "function",
          "description": "This function rotates the input register right through the carry.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur if there is a memory access issue."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "Mutable reference to the GBState struct."
            },
            {
              "name": "r_i",
              "type": "u8",
              "description": "Input register."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Result indicating whether the operation was successful or an error occurred."
          },
          "prototype": "pub fn rr(state: &mut GBState, r_i: u8) -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Rotate Right through Carry",
          "description": "Rotate the input register right through the carry.",
          "example": "// Rotate Right through Carry the input register\nrr(&mut state, r_i)?;",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn sla(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // Shift left Arithmetic (b0=0) the input register\n    let mut n = state.r_reg(r_i)?;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n >> 7) << 4;\n    n <<= 1;\n\n    if n == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.w_reg(r_i, n)\n}",
    "name": "opcodes_chunk_25.rs",
    "path": "src/opcodes_chunk_25.rs",
    "originalPath": "src/opcodes_chunk_25.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This JSON object provides a detailed description and examples for the functions defined in the `src/opcodes_chunk_25.rs` file. These functions are used to implement the SLA (Shift Left Arithmetic) operation in a Game Boy emulator. The examples include code snippets with comments explaining their functionality, as well as possible error scenarios. The JSON follows a specific structure and allows for easy reference and identification of the functions.",
      "references": [
        {
          "name": "sla",
          "category": "function",
          "description": "Shifts the input register left by 1 bit and updates the flags accordingly.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while accessing the memory."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the Game Boy state."
            },
            {
              "name": "r_i",
              "type": "u8",
              "description": "The index of the input register."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Result indicating success or an error of type `MemError`."
          },
          "prototype": "pub fn sla(state: &mut GBState, r_i: u8) -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Shifts the register `R0` left by 1 bit using the `sla` function.",
          "example": "let mut state = GBState::new();\nlet register_index = 0;\n\nsla(&mut state, register_index)?;",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Shifts the register `RA` left by 1 bit using the `sla` function. Handles the memory error case.",
          "example": "let mut state = GBState::new();\nlet register_index = 10;\n\nmatch sla(&mut state, register_index) {\n    Ok(()) => {} // Handle success\n    Err(e) => println!(\"Error: {}\", e), // Handle memory error\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn sra(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // Shift right Arithmetic (b7=b7) the input register\n    let mut n = state.r_reg(r_i)?;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n & 0b1) << 4;\n    let b7 = n & 0b10000000;\n    n >>= 1;\n    n |= b7;\n\n    if n == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.w_reg(r_i, n)\n}",
    "name": "opcodes_chunk_26.rs",
    "path": "src/opcodes_chunk_26.rs",
    "originalPath": "src/opcodes_chunk_26.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "The provided code snippet is a function called `sra` in Rust. It takes two parameters, `state` of type `&mut GBState` and `r_i` of type `u8`. The function shifts the input register `n` one bit to the right and updates the flags in the `state` accordingly. If the resulting `n` is zero, the zero flag is set. The function returns `Result<(), MemError>`, where `MemError` is an error type.",
      "references": [
        {
          "name": "sra",
          "category": "function",
          "description": "Shifts the input register one bit to the right and updates the flags in the `state` struct accordingly.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error type representing memory related errors."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the `GBState` struct."
            },
            {
              "name": "r_i",
              "type": "u8",
              "description": "The input register."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the operation is successful, or `Err` with a `MemError` if a memory error occurs."
          }
        }
      ],
      "examples": [
        {
          "title": "Example",
          "description": "Example usage of the `sra` function",
          "example": "cargo run --bin my_program",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn swap(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // Swap the high nibble and low nibble\n    let mut n = state.r_reg(r_i)?;\n\n    let nibble_low = n & 0b1111;\n    let nibble_high = n >> 4;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n\n    n = nibble_high | (nibble_low << 4);\n\n    if n == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.w_reg(r_i, n)\n}",
    "name": "opcodes_chunk_27.rs",
    "path": "src/opcodes_chunk_27.rs",
    "originalPath": "src/opcodes_chunk_27.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the definition of the `swap` function in Rust. The `swap` function is used to swap the high nibble and low nibble of a given value. This function is part of a larger project that implements a GameBoy emulator (`GBState`) and is responsible for modifying the state of the CPU registers and flags.",
      "references": [
        {
          "name": "swap",
          "category": "function",
          "description": "Swaps the high nibble and low nibble of a given value.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs when there is a problem accessing the memory."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the `GBState` which represents the current state of the GameBoy emulator."
            },
            {
              "name": "r_i",
              "type": "u8",
              "description": "The index of the CPU register to swap the nibbles of."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A `Result` indicating whether the operation was successful or if an error occurred."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Swapping nibbles using the `swap` function.",
          "example": "pub fn swap_example(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // Swap the high nibble and low nibble\n    let mut n = state.r_reg(r_i)?;\n\n    let nibble_low = n & 0b1111;\n    let nibble_high = n >> 4;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n\n    n = nibble_high | (nibble_low << 4);\n\n    if n == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.w_reg(r_i, n)\n}\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Swapping nibbles using the `swap` function (CLI).",
          "example": "// Usage: <base_command> swap <register_index>\n\n<base_command> swap 12\n",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn srl(state: &mut GBState, r_i: u8) -> Result<(), MemError> {\n    // Shift right Logical (b7=0) the input register\n    let mut n = state.r_reg(r_i)?;\n\n    state.cpu.r[reg::F as usize] &= !(flag::H | flag::N | flag::ZF | flag::CY);\n    state.cpu.r[reg::F as usize] |= (n & 0b1) << 4;\n    n >>= 1;\n\n    if n == 0 {\n        state.cpu.r[reg::F as usize] |= flag::ZF;\n    }\n\n    state.w_reg(r_i, n)\n}\n\npub fn bit(state: &mut GBState, n1: u8, n2: u8) -> Result<(), MemError> {\n    let z = (((state.r_reg(n2)? >> n1) & 1) ^ 1) << 7;\n\n    state.cpu.r[reg::F as usize] &= !(flag::N | flag::ZF);\n    state.cpu.r[reg::F as usize] |= flag::H | z;\n    Ok(())\n}\n\npub fn set(state: &mut GBState, n1: u8, n2: u8) -> Result<(), MemError> {\n    state.w_reg(n2, state.r_reg(n2)? | (1 << n1))\n}",
    "name": "opcodes_chunk_28.rs",
    "path": "src/opcodes_chunk_28.rs",
    "originalPath": "src/opcodes_chunk_28.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "The provided content is a Rust file containing three functions: `srl`, `bit`, and `set`. The `srl` function performs a shift right logical operation on an input register, updating the register and the flags accordingly. The `bit` function checks a specific bit of a register and updates the flags based on the result. The `set` function sets a specific bit of a register. All three functions return a `Result` indicating whether an error occurred during the execution. The errors that can occur are defined as `MemError`. This JSON object provides example code for each function, including comments explaining the functionality, possible errors, and usage.",
      "references": [
        {
          "name": "srl",
          "category": "function",
          "description": "Shift right Logical (b7=0) the input register",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred during memory access"
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the Game Boy state"
            },
            {
              "name": "r_i",
              "type": "u8",
              "description": "The index of the input register"
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the operation succeeded, otherwise an `Err` containing a `MemError`"
          }
        }
      ],
      "examples": [
        {
          "title": "Example srl Usage",
          "description": "Example usage of the `srl` function.",
          "example": "// srl example\ngameboy_state.srl(&mut state, 2)?;\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn res(state: &mut GBState, n1: u8, n2: u8) -> Result<(), MemError> {\n    state.w_reg(n2, state.r_reg(n2)? & !(1 << n1))\n}",
    "name": "opcodes_chunk_29.rs",
    "path": "src/opcodes_chunk_29.rs",
    "originalPath": "src/opcodes_chunk_29.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation code for the `res` function in Rust. The `res` function modifies a register value located in a Game Boy (GB) state by clearing a specified bit. It takes two arguments: `state`, a mutable reference to the current GB state, and `n1` and `n2`, which indicate the bit position and the register to modify, respectively. The function clears the bit at position `n1` in register `n2` by performing a bitwise AND operation with the complement of a shifted bitmask. The resulting GB state is returned as a `Result` type, indicating success or a memory error.",
      "references": [
        {
          "name": "res",
          "category": "function",
          "description": "Clears a specific bit in the register of a Game Boy (GB) state.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the current GB state."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The bit position to clear."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The register to modify."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "The modified GB state as a `Result` type, indicating success or a memory error."
          }
        }
      ],
      "examples": [
        {
          "title": "Clear Bit from Register",
          "description": "Example usage of the `res` function to clear a bit in a register.",
          "example": "// Import the required types and function\nuse crate::GBState;\nuse crate::MemError;\n\n// Define a `res` function\npub fn res(state: &mut GBState, n1: u8, n2: u8) -> Result<(), MemError> {\n    state.w_reg(n2, state.r_reg(n2)? & !(1 << n1))\n}\n\n// Create a GBState instance\nlet mut gb_state = GBState::new();\n\n// Update the register value by clearing bit 3 of register 1\nlet result = res(&mut gb_state, 3, 1);\n\n// Handle the result\nmatch result {\n    Ok(()) => println!(\"Bit cleared successfully!\"),\n    Err(e) => println!(\"Error: {}\", e),\n}\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn op00(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError> {\n    // Dispatcher for the instructions starting with 0b00 based on their 3 LSB\n    match n2 {\n        0b000 => match n1 {\n            0b000 => Ok(4),\n            0b001 => ldnnsp(state),\n            0b010 => todo!(\"STOP\"), // STOP\n            0b011 => jr8(state),\n            _ => jrcc8(state, n1),\n        },\n        0b001 => match n1 {\n            0b001 | 0b011 | 0b101 | 0b111 => Ok(addhlrr(state, n1 >> 1)),\n            0b000 | 0b010 | 0b100 | 0b110 => {\n                let p = r_16b_from_pc(state)?;\n                ldrr16(state, n1 >> 1, p);\n                Ok(12)\n            }\n            _ => panic!(),\n        },\n        0b010 => ld00a(state, n1),\n        0b011 => match n1 {",
    "name": "opcodes_chunk_30.rs",
    "path": "src/opcodes_chunk_30.rs",
    "originalPath": "src/opcodes_chunk_30.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of various opcode functions for a Game Boy emulator. The 'op00' function is a dispatcher function for instructions starting with '0b00' based on their 3 least significant bits (LSB). It matches the value of 'n2' and performs different operations accordingly. The function takes a mutable reference to the 'GBState' struct and two 'u8' values 'n1' and 'n2' as input parameters. It returns a 'Result' enum with an 'Ok' variant containing an 'u64' value or an 'Err' variant containing a 'MemError' enum value in case of an error.",
      "references": [
        {
          "name": "op00",
          "category": "function",
          "description": "Dispatcher function for instructions starting with '0b00'. Matches 'n2' value and performs different operations based on it.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "Mutable reference to the 'GBState' struct."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "First 'u8' value."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "Second 'u8' value."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "Returns a 'Result' enum with an 'Ok' variant containing an 'u64' value or an 'Err' variant containing a 'MemError' enum value."
          },
          "subreferences": [
            {
              "name": "ldnnsp",
              "category": "function",
              "description": "Load 'nn' into 'SP' register.",
              "parameters": [
                {
                  "name": "state",
                  "type": "&mut GBState",
                  "description": "Mutable reference to the 'GBState' struct."
                }
              ],
              "returns": null
            },
            {
              "name": "jr8",
              "category": "function",
              "description": "Jump relative by 'n' bytes.",
              "parameters": [
                {
                  "name": "state",
                  "type": "&mut GBState",
                  "description": "Mutable reference to the 'GBState' struct."
                }
              ],
              "returns": null
            },
            {
              "name": "jrcc8",
              "category": "function",
              "description": "Jump relative by 'n' bytes if 'cc' condition is met.",
              "parameters": [
                {
                  "name": "state",
                  "type": "&mut GBState",
                  "description": "Mutable reference to the 'GBState' struct."
                },
                {
                  "name": "n1",
                  "type": "u8",
                  "description": "First 'u8' value."
                }
              ],
              "returns": null
            },
            {
              "name": "addhlrr",
              "category": "function",
              "description": "Add 'HL' register with 'RR' register based on 'n1' value.",
              "parameters": [
                {
                  "name": "state",
                  "type": "&mut GBState",
                  "description": "Mutable reference to the 'GBState' struct."
                },
                {
                  "name": "n1",
                  "type": "u8",
                  "description": "First 'u8' value."
                }
              ],
              "returns": {
                "type": "Result<u64, MemError>",
                "description": "Returns a 'Result' enum with an 'Ok' variant containing an 'u64' value or an 'Err' variant containing a 'MemError' enum value."
              }
            },
            {
              "name": "r_16b_from_pc",
              "category": "function",
              "description": "Read 16-bit value from program counter ('PC').",
              "parameters": [
                {
                  "name": "state",
                  "type": "&mut GBState",
                  "description": "Mutable reference to the 'GBState' struct."
                }
              ],
              "returns": {
                "type": "Result<u16, MemError>",
                "description": "Returns a 'Result' enum with an 'Ok' variant containing an 'u16' value or an 'Err' variant containing a 'MemError' enum value."
              }
            },
            {
              "name": "ldrr16",
              "category": "function",
              "description": "Load register 'RR' with 16-bit value 'p' based on 'n1' value.",
              "parameters": [
                {
                  "name": "state",
                  "type": "&mut GBState",
                  "description": "Mutable reference to the 'GBState' struct."
                },
                {
                  "name": "n1",
                  "type": "u8",
                  "description": "First 'u8' value."
                },
                {
                  "name": "p",
                  "type": "u16",
                  "description": "16-bit value."
                }
              ],
              "returns": null
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Performing 'op00' operation with 'n1' and 'n2' values.",
          "example": "let mut state = GBState::default();\nop00(&mut state, 0b001, 0b000);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Performing 'op00' operation with 'n1' and 'n2' values along with calling sub-reference function 'ldnnsp'.",
          "example": "let mut state = GBState::default();\nop00(&mut state, 0b001, 0b001);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 3",
          "description": "Performing 'op00' operation with 'n1' and 'n2' values along with calling sub-reference function 'jrcc8'.",
          "example": "let mut state = GBState::default();\nop00(&mut state, 0b000, 0b011);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 4",
          "description": "Performing 'op00' operation with 'n1' and 'n2' values along with calling sub-reference function 'addhlrr'.",
          "example": "let mut state = GBState::default();\nop00(&mut state, 0b001, 0b001);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 5",
          "description": "Performing 'op00' operation with 'n1' and 'n2' values along with calling multiple sub-reference functions 'r_16b_from_pc' and 'ldrr16'.",
          "example": "let mut state = GBState::default();\nop00(&mut state, 0b010, 0b000);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "0b001 | 0b011 | 0b101 | 0b111 => Ok(dec16(state, n1 >> 1)),\n            0b000 | 0b010 | 0b100 | 0b110 => Ok(inc16(state, n1 >> 1)),\n            _ => panic!(),\n        },\n        0b100 => inc8(state, n1),\n        0b101 => dec8(state, n1),\n        0b110 => ldr8(state, n1),\n        0b111 => {\n            match n1 {\n                0b000 => rlc(state, 7)?,\n                0b001 => rrc(state, 7)?,\n                0b010 => rl(state, 7)?,\n                0b011 => rr(state, 7)?,\n                0b100 => daa(state),\n                0b101 => cpl(state),\n                0b110 => scf(state),\n                0b111 => ccf(state),\n                _ => panic!(),\n            };\n            Ok(4)\n        }\n        _ => panic!(),\n    }\n}",
    "name": "opcodes_chunk_31.rs",
    "path": "src/opcodes_chunk_31.rs",
    "originalPath": "src/opcodes_chunk_31.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "The provided content is an excerpt from an assembly language file (`opcodes_chunk_31.rs`) that contains a match statement with various patterns and corresponding function calls. The code is responsible for executing different operations based on the binary values of `n1` and `state`. This JSON object includes example code snippets for each function definition, along with their descriptions, possible errors, and parameters if applicable.",
      "references": [
        {
          "name": "dec16",
          "category": "function",
          "description": "Decreases the value of a 16-bit integer by 1.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            },
            {
              "name": "n1",
              "type": "u16",
              "description": "A 16-bit integer."
            }
          ]
        },
        {
          "name": "inc16",
          "category": "function",
          "description": "Increases the value of a 16-bit integer by 1.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            },
            {
              "name": "n1",
              "type": "u16",
              "description": "A 16-bit integer."
            }
          ]
        },
        {
          "name": "inc8",
          "category": "function",
          "description": "Increases the value of an 8-bit integer by 1.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "An 8-bit integer."
            }
          ]
        },
        {
          "name": "dec8",
          "category": "function",
          "description": "Decreases the value of an 8-bit integer by 1.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "An 8-bit integer."
            }
          ]
        },
        {
          "name": "ldr8",
          "category": "function",
          "description": "Loads an 8-bit value from memory.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "An 8-bit integer representing an address in memory."
            }
          ]
        },
        {
          "name": "rlc",
          "category": "function",
          "description": "Rotates the bits of a byte left, and sets the carry flag based on the leftmost bit.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            }
          ],
          "returns": {
            "type": "Result<u8, StateError>",
            "description": "The result of the rotation operation."
          }
        },
        {
          "name": "rrc",
          "category": "function",
          "description": "Rotates the bits of a byte right, and sets the carry flag based on the rightmost bit.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            }
          ],
          "returns": {
            "type": "Result<u8, StateError>",
            "description": "The result of the rotation operation."
          }
        },
        {
          "name": "rl",
          "category": "function",
          "description": "Rotates the bits of a byte left through the carry flag.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            }
          ],
          "returns": {
            "type": "Result<u8, StateError>",
            "description": "The result of the rotation operation."
          }
        },
        {
          "name": "rr",
          "category": "function",
          "description": "Rotates the bits of a byte right through the carry flag.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            }
          ],
          "returns": {
            "type": "Result<u8, StateError>",
            "description": "The result of the rotation operation."
          }
        },
        {
          "name": "daa",
          "category": "function",
          "description": "Decimal adjust the accumulator after BCD arithmetic operations.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            }
          ]
        },
        {
          "name": "cpl",
          "category": "function",
          "description": "Complements (bitwise negation) of the accumulator value.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            }
          ]
        },
        {
          "name": "scf",
          "category": "function",
          "description": "Sets the carry flag.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            }
          ]
        },
        {
          "name": "ccf",
          "category": "function",
          "description": "Complements (toggles) the carry flag.",
          "errors": [
            {
              "name": "state_error",
              "description": "State error occurred."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The state of the system."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example",
          "description": "Decoding opcodes using match statements.",
          "example": "// Include the necessary imports for State struct\nuse crate::State;\nuse crate::errors::StateError;\n\n// Match statement to decode opcodes\nmatch n1 {\n    0b001 | 0b011 | 0b101 | 0b111 => Ok(dec16(state, n1 >> 1)),\n    0b000 | 0b010 | 0b100 | 0b110 => Ok(inc16(state, n1 >> 1)),\n    _ => panic!(),\n},\n0b100 => inc8(state, n1),\n0b101 => dec8(state, n1),\n0b110 => ldr8(state, n1),\n0b111 => {\n    match n1 {\n        0b000 => rlc(state, 7)?, // Rotate left and set carry flag\n        0b001 => rrc(state, 7)?, // Rotate right and set carry flag\n        0b010 => rl(state, 7)?, // Rotate left through carry flag\n        0b011 => rr(state, 7)?, // Rotate right through carry flag\n        0b100 => daa(state), // Decimal adjust accumulator\n        0b101 => cpl(state), // Complement accumulator\n        0b110 => scf(state), // Set carry flag\n        0b111 => ccf(state), // Complement carry flag\n        _ => panic!(),\n    };\n    Ok(4)\n}\n_ => panic!(),",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn op01(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError> {\n    // Dispatcher for the instructions starting with 0b01 (LD r,r and HALT)\n    if n1 == 0b110 && n2 == 0b110 {\n        todo!(\"HALT\")\n    } else {\n        ldrr(state, n1, n2)?;\n\n        if n1 == 0b110 || n2 == 0b110 {\n            Ok(8)\n        } else {\n            Ok(4)\n        }\n    }\n}",
    "name": "opcodes_chunk_32.rs",
    "path": "src/opcodes_chunk_32.rs",
    "originalPath": "src/opcodes_chunk_32.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of the `op01` function which is part of the GBState struct. The `op01` function is responsible for executing the opcode `0b01` instructions, specifically `LD r,r` (load register to register) and `HALT` instructions. The function takes three parameters: a mutable reference to GBState, and two unsigned 8-bit integers `n1` and `n2`. It returns a `Result` which contains either an `u64` value or a `MemError` if an error occurs during execution. The function first checks if the `n1` and `n2` values represent the `HALT` opcode, and if so, it raises a `todo!()` macro error. Otherwise, it calls the `ldrr` function passing the `state`, `n1`, and `n2` values. The `ldrr` function loads the value from one register into another. After that, the function checks if either `n1` or `n2` represent register `0b110` and returns `Ok(8)` if true, otherwise it returns `Ok(4)`. This function is used to handle specific opcode instructions and update the state of the Game Boy.",
      "references": [
        {
          "name": "op01",
          "category": "function",
          "description": "Executes opcode `0b01` instructions (`LD r,r` and `HALT`)",
          "errors": [
            {
              "name": "Result",
              "description": "The `op01` function returns a `Result` which contains either an `u64` value or a `MemError` if an error occurs during execution."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "An unsigned 8-bit integer representing the first parameter of the opcode."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "An unsigned 8-bit integer representing the second parameter of the opcode."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "A `Result` which contains either an `u64` value representing the number of cycles executed or a `MemError` if an error occurs during execution."
          },
          "prototype": "pub fn op01(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError>"
        },
        {
          "name": "ldrr",
          "category": "function",
          "description": "Load register to register - Copies the value from one register to another.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "An unsigned 8-bit integer representing the first register."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "An unsigned 8-bit integer representing the second register."
            }
          ],
          "returns": null,
          "prototype": "fn ldrr(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Calling the `op01` function with valid parameters",
          "example": "// File: root/src/opcodes_chunk_32.rs\n\nfn main() {\n    use crate::GBState;\n    use crate::opcodes_chunk_32::op01;\n\n    let mut state = GBState::new();\n    let n1 = 0b110;\n    let n2 = 0b101;\n    let result = op01(&mut state, n1, n2);\n    match result {\n        Ok(cycles) => println!(\"Opcode executed successfully. Cycles: {}\", cycles),\n        Err(error) => println!(\"Error occurred: {:?}\", error),\n    }\n}\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn op10(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError> {\n    // Dispatcher for the instructions starting with 0b10 (Arithmetic)\n    match n1 {\n        0b000 => add(state, state.r_reg(n2)?),\n        0b001 => adc(state, state.r_reg(n2)?),\n        0b010 => sub(state, state.r_reg(n2)?),\n        0b011 => sbc(state, state.r_reg(n2)?),\n        0b100 => and(state, state.r_reg(n2)?),\n        0b101 => xor(state, state.r_reg(n2)?),\n        0b110 => or(state, state.r_reg(n2)?),\n        0b111 => cp(state, state.r_reg(n2)?),\n        _ => panic!(),\n    }\n\n    if n2 == 0b110 {\n        Ok(8)\n    } else {\n        Ok(4)\n    }\n}",
    "name": "opcodes_chunk_33.rs",
    "path": "src/opcodes_chunk_33.rs",
    "originalPath": "src/opcodes_chunk_33.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of the op10 function, which is a dispatcher for instructions starting with 0b10. It performs various arithmetic operations based on the value of n1 and n2. The function returns the result of the operation and handles possible memory errors using the MemError enum. There are comments in the code that explain the purpose of each operation and the return value based on the value of n2.",
      "references": [
        {
          "name": "op10",
          "category": "function",
          "description": "This function is a dispatcher for instructions starting with 0b10. It performs arithmetic operations based on the value of n1 and n2.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to the GBState struct."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The first value used for choosing the arithmetic operation."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The second value used for choosing the arithmetic operation."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "The result of the arithmetic operation or a MemError if a memory error occurs."
          },
          "errors": [
            {
              "name": "MemError",
              "description": "An error enum representing possible memory errors."
            }
          ]
        },
        {
          "name": "add",
          "category": "function",
          "description": "This function performs addition of the given value to the GBState register."
        },
        {
          "name": "adc",
          "category": "function",
          "description": "This function performs addition with carry of the given value to the GBState register."
        },
        {
          "name": "sub",
          "category": "function",
          "description": "This function performs subtraction of the given value from the GBState register."
        },
        {
          "name": "sbc",
          "category": "function",
          "description": "This function performs subtraction with carry of the given value from the GBState register."
        },
        {
          "name": "and",
          "category": "function",
          "description": "This function performs bitwise AND operation of the given value with the GBState register."
        },
        {
          "name": "xor",
          "category": "function",
          "description": "This function performs bitwise XOR operation of the given value with the GBState register."
        },
        {
          "name": "or",
          "category": "function",
          "description": "This function performs bitwise OR operation of the given value with the GBState register."
        },
        {
          "name": "cp",
          "category": "function",
          "description": "This function performs comparison of the given value with the GBState register."
        }
      ],
      "examples": [
        {
          "title": "Perform addition operation",
          "description": "This example demonstrates how to use the op10 function to perform addition operation.",
          "example": "src/opcodes_chunk_33.rs:op10(&mut state, 0b000, 1)?;\n\n// The above line calls op10 with n1 as 0b000 and n2 as 1, which will call the add function.",
          "example_markdown_language": "rust"
        },
        {
          "title": "Perform bitwise AND operation",
          "description": "This example demonstrates how to use the op10 function to perform bitwise AND operation.",
          "example": "src/opcodes_chunk_33.rs:op10(&mut state, 0b100, 2)?;\n\n// The above line calls op10 with n1 as 0b100 and n2 as 2, which will call the and function.",
          "example_markdown_language": "rust"
        },
        {
          "title": "Dispatch instruction with n2 as 0b110",
          "description": "This example demonstrates how to use the op10 function to dispatch an instruction with n2 as 0b110.",
          "example": "src/opcodes_chunk_33.rs:op10(&mut state, 0b011, 0b110)?;\n\n// The above line calls op10 with n1 as 0b011 and n2 as 0b110, which will call the sbc function.\n// The function returns Ok(8) because n2 is equal to 0b110.",
          "example_markdown_language": "rust"
        },
        {
          "title": "Dispatch instruction with n2 other than 0b110",
          "description": "This example demonstrates how to use the op10 function to dispatch an instruction with n2 other than 0b110.",
          "example": "src/opcodes_chunk_33.rs:op10(&mut state, 0b111, 0b100)?;\n\n// The above line calls op10 with n1 as 0b111 and n2 as 0b100, which will call the cp function.\n// The function returns Ok(4) because n2 is not equal to 0b110.",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn op11(state: &mut GBState, n1: u8, n2: u8) -> Result<u64, MemError> {\n    match n2 {\n        0b000 => match n1 {\n            0b100 => {\n                let n = r_8b_from_pc(state)?;\n                ldnna(state, n as u16 | 0xff00)?;\n                Ok(12)\n            }\n            0b101 => addsp8(state),\n            0b110 => {\n                let n = r_8b_from_pc(state)?;\n                ldann(state, n as u16 | 0xff00)?;\n                Ok(12)\n            }\n            0b111 => {\n                let n = r_8b_from_pc(state)?;\n                ldrr16(state, reg::HL, n as u16 + state.cpu.sp);\n                Ok(12)\n            }\n            _ => retcc(state, n1 & 0b11),\n        },\n        0b001 => match n1 {\n            0b001 => ret(state),\n            0b011 => {",
    "name": "opcodes_chunk_34.rs",
    "path": "src/opcodes_chunk_34.rs",
    "originalPath": "src/opcodes_chunk_34.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file defines the `op11` function which is used to perform various operations based on the values of `n1` and `n2`. The function `op11` takes in a mutable reference to a `GBState` struct, as well as two `u8` values (`n1` and `n2`). It returns a `Result` containing an `u64` value or a `MemError` if an error occurs. The function uses pattern matching to determine the action to be taken based on the values of `n1` and `n2`. The possible operations include loading data from memory, adding an immediate value to the stack pointer, and returning based on certain conditions. The function returns the number of cycles taken for each operation.",
      "references": [
        {
          "name": "op11",
          "category": "function",
          "description": "The `op11` function performs various operations based on the values of `n1` and `n2`. It takes in a mutable reference to a `GBState` struct, as well as two `u8` values (`n1` and `n2`), and returns a `Result` containing an `u64` value or a `MemError` if an error occurs.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The first `u8` value."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The second `u8` value."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "A `Result` containing an `u64` value or a `MemError` if an error occurs."
          }
        },
        {
          "name": "r_8b_from_pc",
          "category": "function",
          "description": "Gets an `u8` value from the program counter (PC).",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            }
          ],
          "returns": {
            "type": "Result<u8, MemError>",
            "description": "A `Result` containing the `u8` value from the program counter (PC) or a `MemError` if an error occurs."
          }
        },
        {
          "name": "ldnna",
          "category": "function",
          "description": "Loads the value `n` (converted to `u16` and OR'ed with `0xff00`) into the address pointed by `state`.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n",
              "type": "u16",
              "description": "The `u16` value to be loaded."
            }
          ],
          "returns": null
        },
        {
          "name": "addsp8",
          "category": "function",
          "description": "Adds an immediate `u8` value to the stack pointer (SP) in `state`.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "A `Result` containing the number of cycles taken for the operation or a `MemError` if an error occurs."
          }
        },
        {
          "name": "ldann",
          "category": "function",
          "description": "Loads the value `n` (converted to `u16` and OR'ed with `0xff00`) into the memory address pointed by `state`.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n",
              "type": "u16",
              "description": "The `u16` value to be loaded."
            }
          ],
          "returns": null
        },
        {
          "name": "ldrr16",
          "category": "function",
          "description": "Loads the value `n` (converted to `u16` and added with the stack pointer) into the register `reg::HL` in `state`.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "reg",
              "type": "reg::Reg16",
              "description": "The register to store the value."
            },
            {
              "name": "n",
              "type": "u16",
              "description": "The `u16` value to be loaded."
            }
          ],
          "returns": null
        },
        {
          "name": "retcc",
          "category": "function",
          "description": "Returns based on the condition code (`n1 & 0b11`) in `state`.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The `u8` value representing the condition code."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "A `Result` containing the number of cycles taken for the operation or a `MemError` if an error occurs."
          }
        },
        {
          "name": "ret",
          "category": "function",
          "description": "Returns from a subroutine in `state`.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "A `Result` containing the number of cycles taken for the operation or a `MemError` if an error occurs."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Load data from memory",
          "example": "let mut state = GBState::new();\nop11(&mut state, 0b100, 0b000);\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Add immediate value to stack pointer",
          "example": "let mut state = GBState::new();\nop11(&mut state, 0b101, 0b000);\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 3",
          "description": "Load value into memory address",
          "example": "let mut state = GBState::new();\nop11(&mut state, 0b110, 0b000);\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 4",
          "description": "Load value into register",
          "example": "let mut state = GBState::new();\nop11(&mut state, 0b111, 0b000);\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 5",
          "description": "Return based on condition code",
          "example": "let mut state = GBState::new();\nop11(&mut state, 0bXXX, 0b001);\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 6",
          "description": "Return from subroutine",
          "example": "let mut state = GBState::new();\nop11(&mut state, 0bXXX, 0b001);\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "state.mem.ime = true;",
    "name": "opcodes_chunk_35.rs",
    "path": "src/opcodes_chunk_35.rs",
    "originalPath": "src/opcodes_chunk_35.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the definition and implementation of various functions related to opcodes in a Rust program. The code provided sets the 'ime' (interrupt master enable) flag in the 'mem' (memory) state to true.",
      "references": [
        {
          "name": "set_ime",
          "category": "function",
          "description": "This function sets the interrupt master enable flag to the provided value.",
          "parameters": [
            {
              "name": "value",
              "type": "bool",
              "description": "The boolean value to set the interrupt master enable flag to."
            }
          ],
          "returns": null,
          "prototype": "fn set_ime(value: bool)"
        },
        {
          "name": "state",
          "category": "structure",
          "description": "The structure that holds the current state of the program.",
          "publics": true
        },
        {
          "name": "state.mem",
          "category": "field",
          "description": "The field that represents the memory component of the program's state.",
          "publics": true
        },
        {
          "name": "state.mem.ime",
          "category": "field",
          "description": "The field that represents the interrupt master enable flag in the memory component of the program's state.",
          "publics": true
        }
      ],
      "examples": [
        {
          "title": "Set IME to true",
          "description": "Example code that sets the interrupt master enable flag to true.",
          "example": "state.mem.ime = true; // Set IME to true",
          "example_markdown_language": "rust"
        },
        {
          "title": "Set IME using set_ime function",
          "description": "Example code that sets the interrupt master enable flag to true using the set_ime function.",
          "example": "set_ime(true); // Set IME to true",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "ret(state)\n            }\n            0b101 => Ok(jphl(state)),\n            0b111 => Ok(ldsphl(state)),\n            _ => {\n                let p = pop(state)?;\n                state.cpu.r[(n1 >> 1) as usize * 2 + 1] = (p & 0xff) as u8;\n                state.cpu.r[(n1 >> 1) as usize * 2] = (p >> 8) as u8;\n                Ok(12)\n            }\n        },\n        0b010 => match n1 {\n            0b100 => {\n                ldnna(state, state.cpu.r[reg::C as usize] as u16 | 0xff00)?;\n                Ok(8)\n            }\n            0b101 => {\n                let nn = r_16b_from_pc(state)?;\n                ldnna(state, nn)?;\n                Ok(16)\n            }\n            0b110 => {\n                ldann(state, state.cpu.r[reg::C as usize] as u16 | 0xff00)?;\n                Ok(8)",
    "name": "opcodes_chunk_36.rs",
    "path": "src/opcodes_chunk_36.rs",
    "originalPath": "src/opcodes_chunk_36.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of various opcodes for a specific chunk in a program. It defines multiple functions that handle different opcode cases and perform corresponding operations. The functions included in this file are 'ret', 'jphl', 'ldsphl', 'pop', 'ldnna', 'r_16b_from_pc', and 'ldann'. The code inside these functions handles different scenarios and updates the state of the CPU accordingly. The file also includes error handling for certain cases where the input parameters are invalid or the program encounters an error. The examples provided demonstrate the usage of these functions with explanations and the possible errors that can occur.",
      "references": [
        {
          "name": "ret",
          "category": "function",
          "description": "This function performs the return operation by retrieving the current state and returning it.",
          "errors": [],
          "parameters": [],
          "returns": {
            "type": "Result<u8, Error>",
            "description": "Returns the state after performing the return operation."
          }
        },
        {
          "name": "jphl",
          "category": "function",
          "description": "This function performs the jump to HL (HL is a register) operation.",
          "errors": [],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The current state of the CPU."
            }
          ],
          "returns": {
            "type": "Result<u8, Error>",
            "description": "Returns the state after performing the jump operation."
          }
        },
        {
          "name": "ldsphl",
          "category": "function",
          "description": "This function loads the stack pointer (SP) from HL (HL is a register).",
          "errors": [],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The current state of the CPU."
            }
          ],
          "returns": {
            "type": "Result<u8, Error>",
            "description": "Returns the state after loading the stack pointer."
          }
        },
        {
          "name": "pop",
          "category": "function",
          "description": "This function pops the top value from the stack and updates the state accordingly.",
          "errors": [
            {
              "name": "StackUnderflow",
              "description": "Occurs when the stack is empty."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The current state of the CPU."
            }
          ],
          "returns": {
            "type": "Result<u16, Error>",
            "description": "Returns the popped value from the stack."
          }
        },
        {
          "name": "ldnna",
          "category": "function",
          "description": "This function loads a value into the memory address specified by the input parameter.",
          "errors": [
            {
              "name": "InvalidMemoryAddress",
              "description": "Occurs when the memory address is invalid."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The current state of the CPU."
            },
            {
              "name": "address",
              "type": "u16",
              "description": "The memory address to load the value into."
            }
          ],
          "returns": {
            "type": "Result<(), Error>",
            "description": "Returns Ok(()) if the operation is successful."
          }
        },
        {
          "name": "r_16b_from_pc",
          "category": "function",
          "description": "This function reads a 16-bit value from the program counter (PC) and updates the PC accordingly.",
          "errors": [],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The current state of the CPU."
            }
          ],
          "returns": {
            "type": "Result<u16, Error>",
            "description": "Returns the 16-bit value read from the PC."
          }
        },
        {
          "name": "ldann",
          "category": "function",
          "description": "This function loads a value into the memory address specified by the input parameter.",
          "errors": [
            {
              "name": "InvalidMemoryAddress",
              "description": "Occurs when the memory address is invalid."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The current state of the CPU."
            },
            {
              "name": "address",
              "type": "u16",
              "description": "The memory address to load the value into."
            }
          ],
          "returns": {
            "type": "Result<(), Error>",
            "description": "Returns Ok(()) if the operation is successful."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Performing a 'ret' operation",
          "example": "ret(state)",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Performing a 'jphl' operation",
          "example": "jphl(state)",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 3",
          "description": "Performing a 'ldsphl' operation",
          "example": "ldsphl(state)",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 4",
          "description": "Performing a 'pop' operation",
          "example": "pop(state)",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 5",
          "description": "Performing a 'ldnna' operation",
          "example": "ldnna(state, address)",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 6",
          "description": "Performing a 'r_16b_from_pc' operation",
          "example": "r_16b_from_pc(state)",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 7",
          "description": "Performing a 'ldann' operation",
          "example": "ldann(state, address)",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "}\n            0b111 => {\n                let nn = r_16b_from_pc(state)?;\n                ldann(state, nn)?;\n                Ok(16)\n            }\n            _ => jpcc16(state, n1 & 0b11),\n        },\n        0b011 => match n1 {\n            0b000 => jp16(state),\n            0b001 => op_bitwise(state), // Bitwise operations\n            0b010 | 0b011 | 0b100 | 0b101 => unimplemented!(),\n            0b110 => {\n                state.mem.ime = false;\n                Ok(4)\n            }\n            0b111 => {\n                state.mem.ime = true;\n                Ok(4)\n            }\n            _ => panic!(),\n        },\n        0b100 => callcc(state, n1 & 0b11),\n        0b101 => match n1 {\n            0b001 => call(state),\n            0b011 | 0b101 | 0b111 => unimplemented!(),",
    "name": "opcodes_chunk_37.rs",
    "path": "src/opcodes_chunk_37.rs",
    "originalPath": "src/opcodes_chunk_37.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This JSON object provides examples of code from the `opcodes_chunk_37.rs` file. It includes commented code examples that demonstrate the usage of functions and also mentions possible errors that can occur during execution.",
      "references": [
        {
          "name": "r_16b_from_pc",
          "category": "function",
          "description": "This function retrieves a 16-bit value from program counter (PC) and stores it in register nn.",
          "errors": [
            {
              "name": "PCValueError",
              "description": "Raised when the PC value is invalid or an error occurs while fetching the value."
            }
          ],
          "keywords": [
            "register",
            "PC",
            "fetch"
          ],
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "Result<u16, PCValueError>",
            "description": "Returns the fetched 16-bit value stored in register nn, or an error if fetching fails."
          },
          "prototype": "fn r_16b_from_pc(state: &mut State) -> Result<u16, PCValueError>;"
        },
        {
          "name": "ldann",
          "category": "function",
          "description": "This function loads a value from memory into an accumulator or register.",
          "errors": [],
          "keywords": [
            "load",
            "memory",
            "accumulator",
            "register"
          ],
          "publics": true,
          "parameters": [
            {
              "name": "state",
              "type": "&mut State",
              "description": "The mutable current state of memory and registers."
            },
            {
              "name": "nn",
              "type": "u16",
              "description": "The 16-bit memory address where the value is stored."
            }
          ],
          "returns": {
            "type": "Result<(), LoadValueError>",
            "description": "Returns `Ok` if the value is successfully loaded into the register, or `Err` if an error occurs during the loading process."
          },
          "prototype": "fn ldann(state: &mut State, nn: u16) -> Result<(), LoadValueError>;"
        },
        {
          "name": "jpcc16",
          "category": "function",
          "description": "This function performs a conditional jump to a 16-bit memory address based on the CC flag.",
          "errors": [],
          "keywords": [
            "jump",
            "conditional",
            "memory address",
            "flag"
          ],
          "publics": true,
          "parameters": [
            {
              "name": "state",
              "type": "&mut State",
              "description": "The mutable current state of memory and registers."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The 8-bit value used to determine the conditional jump."
            }
          ],
          "returns": {
            "type": "Result<(), JPCCError>",
            "description": "Returns `Ok` if the conditional jump is successful, or `Err` if an error occurs during the jump process."
          },
          "prototype": "fn jpcc16(state: &mut State, n1: u8) -> Result<(), JPCCError>;"
        },
        {
          "name": "jp16",
          "category": "function",
          "description": "This function performs an unconditional jump to a 16-bit memory address.",
          "errors": [],
          "keywords": [
            "jump",
            "unconditional",
            "memory address"
          ],
          "publics": true,
          "parameters": [
            {
              "name": "state",
              "type": "&mut State",
              "description": "The mutable current state of memory and registers."
            }
          ],
          "returns": {
            "type": "Result<(), J16Error>",
            "description": "Returns `Ok` if the unconditional jump is successful, or `Err` if an error occurs during the jump process."
          },
          "prototype": "fn jp16(state: &mut State) -> Result<(), J16Error>;"
        },
        {
          "name": "op_bitwise",
          "category": "function",
          "description": "This function performs bitwise operations on registers.",
          "errors": [],
          "keywords": [
            "bitwise",
            "operation",
            "registers"
          ],
          "publics": true,
          "parameters": [
            {
              "name": "state",
              "type": "&mut State",
              "description": "The mutable current state of memory and registers."
            }
          ],
          "returns": {
            "type": "Result<(), BitwiseError>",
            "description": "Returns `Ok` if the bitwise operations are successful, or `Err` if an error occurs during the operations."
          },
          "prototype": "fn op_bitwise(state: &mut State) -> Result<(), BitwiseError>;"
        },
        {
          "name": "unimplemented",
          "category": "function",
          "description": "This function represents an implementation placeholder for future development.",
          "errors": [],
          "keywords": [
            "unimplemented",
            "development"
          ],
          "publics": true,
          "parameters": [],
          "returns": null,
          "prototype": "fn unimplemented() -> !;"
        },
        {
          "name": "callcc",
          "category": "function",
          "description": "This function performs a conditional call to a 16-bit memory address based on the CC flag.",
          "errors": [],
          "keywords": [
            "call",
            "conditional",
            "memory address",
            "flag"
          ],
          "publics": true,
          "parameters": [
            {
              "name": "state",
              "type": "&mut State",
              "description": "The mutable current state of memory and registers."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The 8-bit value used to determine the conditional call."
            }
          ],
          "returns": {
            "type": "Result<(), CallCCError>",
            "description": "Returns `Ok` if the conditional call is successful, or `Err` if an error occurs during the call process."
          },
          "prototype": "fn callcc(state: &mut State, n1: u8) -> Result<(), CallCCError>;"
        },
        {
          "name": "call",
          "category": "function",
          "description": "This function performs an unconditional call to a 16-bit memory address.",
          "errors": [],
          "keywords": [
            "call",
            "unconditional",
            "memory address"
          ],
          "publics": true,
          "parameters": [
            {
              "name": "state",
              "type": "&mut State",
              "description": "The mutable current state of memory and registers."
            }
          ],
          "returns": {
            "type": "Result<(), CallError>",
            "description": "Returns `Ok` if the unconditional call is successful, or `Err` if an error occurs during the call process."
          },
          "prototype": "fn call(state: &mut State) -> Result<(), CallError>;"
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Perform a conditional jump to a memory address based on the CC flag.",
          "example": "// Example 1: Perform a conditional jump\njpcc16(state, 0b00000001);\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Perform bitwise operations on registers.",
          "example": "// Example 2: Perform bitwise operations\nop_bitwise(state);\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 3",
          "description": "Disable interrupt master enable (IME).",
          "example": "// Example 3: Disable IME\nstate.mem.ime = false;\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 4",
          "description": "Enable interrupt master enable (IME).",
          "example": "// Example 4: Enable IME\nstate.mem.ime = true;\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 5",
          "description": "Perform a conditional call to a memory address based on the CC flag.",
          "example": "// Example 5: Perform a conditional call\ncallcc(state, 0b00000001);\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 6",
          "description": "Perform an unconditional call to a memory address.",
          "example": "// Example 6: Perform an unconditional call\ncall(state);\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "_ => {\n                let value = state.cpu.r[(n1 >> 1) as usize * 2 + 1] as u16\n                    | ((state.cpu.r[(n1 >> 1) as usize * 2] as u16) << 8);\n                push(state, value)?;\n                Ok(16)\n            }\n        },\n        0b110 => {\n            let p = r_8b_from_pc(state)?;",
    "name": "opcodes_chunk_38.rs",
    "path": "src/opcodes_chunk_38.rs",
    "originalPath": "src/opcodes_chunk_38.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This JSON object provides example code and error handling for the opcodes_chunk_38.rs file. It includes functions that handle different opcode cases and performs various operations based on the opcode value.",
      "references": [
        {
          "name": "execute_opcode",
          "category": "function",
          "description": "Executes the opcode and performs the appropriate action based on its value.",
          "parameters": [
            {
              "name": "opcode",
              "type": "u8",
              "description": "The opcode to be executed."
            },
            {
              "name": "state",
              "type": "State",
              "description": "The current state of the CPU."
            }
          ],
          "returns": {
            "type": "Result<u8, Error>",
            "description": "The number of cycles used to execute the opcode or an error if execution failed."
          },
          "examples": [
            {
              "title": "Example 1",
              "description": "Executes the opcode 0b110 and handles the result.",
              "example": "let opcode = 0b110;\nlet result = execute_opcode(opcode, state);\nmatch result {\n    Ok(cycles) => println!(\"Opcode executed successfully. Cycles: {}\", cycles),\n    Err(error) => eprintln!(\"Opcode execution failed. Error: {}\", error),\n}",
              "example_markdown_language": "rust"
            }
          ]
        },
        {
          "name": "execute_opcode_0b01",
          "category": "function",
          "description": "Executes the opcode 0b01 and performs the appropriate action based on the value of n1.",
          "errors": [
            {
              "name": "PushError",
              "description": "Failed to push the value into the state."
            }
          ],
          "parameters": [
            {
              "name": "n1",
              "type": "u8",
              "description": "The value of n1."
            },
            {
              "name": "state",
              "type": "State",
              "description": "The current state of the CPU."
            }
          ],
          "returns": {
            "type": "Result<u8, PushError>",
            "description": "The number of cycles used to execute the opcode or an error if pushing failed."
          },
          "examples": [
            {
              "title": "Example 1",
              "description": "Executes the opcode 0b01 with n1 = 3 and handles the result.",
              "example": "let n1 = 3;\nlet result = execute_opcode_0b01(n1, state);\nmatch result {\n    Ok(cycles) => println!(\"Opcode executed successfully. Cycles: {}\", cycles),\n    Err(error) => eprintln!(\"Push failed. Error: {}\", error),\n}",
              "example_markdown_language": "rust"
            }
          ]
        },
        {
          "name": "execute_opcode_0b110",
          "category": "function",
          "description": "Executes the opcode 0b110 and performs the appropriate action.",
          "parameters": [
            {
              "name": "state",
              "type": "State",
              "description": "The current state of the CPU."
            }
          ],
          "examples": [
            {
              "title": "Example 1",
              "description": "Executes the opcode 0b110 and handles the result.",
              "example": "let result = execute_opcode_0b110(state);\nmatch result {\n    Ok(cycles) => println!(\"Opcode executed successfully. Cycles: {}\", cycles),\n    Err(error) => eprintln!(\"Failed to get r_8b from pc. Error: {}\", error),\n}",
              "example_markdown_language": "rust"
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Running the Code",
          "description": "A bash program showing how to run the code from the root project directory.",
          "example": "# Replace <base_command> with the command to run the Rust code\n<base_command> -m opcodes_chunk_38::execute_opcode",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "match n1 {\n                0b000 => add(state, p),\n                0b001 => adc(state, p),\n                0b010 => sub(state, p),\n                0b011 => sbc(state, p),\n                0b100 => and(state, p),\n                0b101 => xor(state, p),\n                0b110 => or(state, p),\n                0b111 => cp(state, p),\n                _ => panic!(),\n            }\n            Ok(8)\n        }\n        0b111 => {\n            let p = n1 << 3;\n\n            push(state, state.cpu.pc)?;\n            state.cpu.pc = p as u16;\n            Ok(16)\n        } // RST\n        _ => panic!(),\n    }\n}",
    "name": "opcodes_chunk_39.rs",
    "path": "src/opcodes_chunk_39.rs",
    "originalPath": "src/opcodes_chunk_39.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains a match statement that handles different cases based on the value of `n1`. If `n1` matches a specific binary pattern, it calls the corresponding functions `add()`, `adc()`, `sub()`, etc., passing the `state` and `p` as arguments. If `n1` matches a specific binary pattern, it executes a series of instructions: it calls the `push()` function passing `state` and `state.cpu.pc` as arguments, assigns `p` to `state.cpu.pc`, and returns `Ok(16)`. If none of the binary patterns are matched, it raises a panic error. The function returns `Ok(8)` if the match statement is successful. ",
      "references": [
        {
          "name": "add",
          "category": "function",
          "description": "This function adds two values: `state` and `p`.",
          "parameters": [
            {
              "name": "state",
              "type": "T",
              "description": "The first value to be added."
            },
            {
              "name": "p",
              "type": "V",
              "description": "The second value to be added."
            }
          ]
        },
        {
          "name": "adc",
          "category": "function",
          "description": "This function performs an addition with carry. It adds two values: `state` and `p`.",
          "parameters": [
            {
              "name": "state",
              "type": "T",
              "description": "The first value to be added."
            },
            {
              "name": "p",
              "type": "V",
              "description": "The second value to be added."
            }
          ]
        },
        {
          "name": "sub",
          "category": "function",
          "description": "This function subtracts two values: `state` and `p`.",
          "parameters": [
            {
              "name": "state",
              "type": "T",
              "description": "The value to be subtracted from."
            },
            {
              "name": "p",
              "type": "V",
              "description": "The value to be subtracted."
            }
          ]
        },
        {
          "name": "sbc",
          "category": "function",
          "description": "This function performs a subtraction with carry. It subtracts two values: `state` and `p`.",
          "parameters": [
            {
              "name": "state",
              "type": "T",
              "description": "The value to be subtracted from."
            },
            {
              "name": "p",
              "type": "V",
              "description": "The value to be subtracted."
            }
          ]
        },
        {
          "name": "and",
          "category": "function",
          "description": "This function performs a logical AND operation between `state` and `p`.",
          "parameters": [
            {
              "name": "state",
              "type": "T",
              "description": "The first value."
            },
            {
              "name": "p",
              "type": "V",
              "description": "The second value."
            }
          ]
        },
        {
          "name": "xor",
          "category": "function",
          "description": "This function performs a logical XOR operation between `state` and `p`.",
          "parameters": [
            {
              "name": "state",
              "type": "T",
              "description": "The first value."
            },
            {
              "name": "p",
              "type": "V",
              "description": "The second value."
            }
          ]
        },
        {
          "name": "or",
          "category": "function",
          "description": "This function performs a logical OR operation between `state` and `p`.",
          "parameters": [
            {
              "name": "state",
              "type": "T",
              "description": "The first value."
            },
            {
              "name": "p",
              "type": "V",
              "description": "The second value."
            }
          ]
        },
        {
          "name": "cp",
          "category": "function",
          "description": "This function compares two values: `state` and `p`.",
          "parameters": [
            {
              "name": "state",
              "type": "T",
              "description": "The first value to be compared."
            },
            {
              "name": "p",
              "type": "V",
              "description": "The second value to be compared."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Match Statement Usage",
          "description": "This example demonstrates the usage of the match statement in the provided code.",
          "example": "let n1: u8 = 0b000;\n\nlet result = match n1 {\n    0b000 => add(state, p),\n    0b001 => adc(state, p),\n    0b010 => sub(state, p),\n    0b011 => sbc(state, p),\n    0b100 => and(state, p),\n    0b101 => xor(state, p),\n    0b110 => or(state, p),\n    0b111 => cp(state, p),\n    _ => panic!()\n};\n\nassert_eq!(result, Ok(8));",
          "example_markdown_language": "rust"
        },
        {
          "title": "RST Pattern Usage",
          "description": "This example demonstrates the usage of the RST pattern in the provided code.",
          "example": "let n1: u8 = 0b111;\n\nif n1 == 0b111 {\n    let p = n1 << 3;\n    push(state, state.cpu.pc)?;\n    state.cpu.pc = p as u16;\n    Ok(16)\n};",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn op_bitwise(state: &mut GBState) -> Result<u64, MemError> {\n    let p = r_8b_from_pc(state)?;\n    let opcode = p >> 6;\n    let n1 = p >> 3 & 0b111;\n    let n2 = p & 0b111;\n\n    match opcode {\n        0b00 => match n1 {\n            0b000 => rlc(state, n2),\n            0b001 => rrc(state, n2),\n            0b010 => rl(state, n2),\n            0b011 => rr(state, n2),\n            0b100 => sla(state, n2),\n            0b101 => sra(state, n2),\n            0b110 => swap(state, n2),\n            0b111 => srl(state, n2),\n            _ => panic!(),\n        },\n        0b01 => bit(state, n1, n2),\n        0b10 => res(state, n1, n2),\n        0b11 => set(state, n1, n2),\n        _ => panic!(),\n    }?;\n    if n2 == 0b110 {\n        Ok(16)\n    } else {\n        Ok(8)\n    }\n}",
    "name": "opcodes_chunk_40.rs",
    "path": "src/opcodes_chunk_40.rs",
    "originalPath": "src/opcodes_chunk_40.rs",
    "chunkTotal": 41,
    "reference_json": {
      "description": "This file contains the implementation of a function called `op_bitwise` which performs bitwise operations on specific registers of a Game Boy state. The function takes a mutable reference to a `GBState` struct and returns a `Result` either containing a `u64` value or a `MemError` if an error occurs. The function first reads an 8-bit value from the program counter and extracts three 2-bit numbers from it using bit shifting and bit masking. Based on the extracted values, the function performs various bitwise operations such as rotate left, rotate right, shift left, shift right, etc., on the specified register. After performing the operation, the function returns the number of cycles consumed by the operation.",
      "references": [
        {
          "name": "op_bitwise",
          "category": "function",
          "description": "Performs bitwise operations on the specified registers of a Game Boy state.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur if there is a memory access failure."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            }
          ],
          "returns": {
            "type": "Result<u64, MemError>",
            "description": "A `Result` either containing a `u64` value or a `MemError` if an error occurs."
          }
        },
        {
          "name": "rlc",
          "category": "function",
          "description": "Performs a rotate left through carry operation on the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "rrc",
          "category": "function",
          "description": "Performs a rotate right through carry operation on the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "rl",
          "category": "function",
          "description": "Performs a rotate left operation on the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "rr",
          "category": "function",
          "description": "Performs a rotate right operation on the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "sla",
          "category": "function",
          "description": "Performs a shift left operation on the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "sra",
          "category": "function",
          "description": "Performs a shift right arithmetic operation on the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "swap",
          "category": "function",
          "description": "Swaps the upper and lower nibbles of the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "srl",
          "category": "function",
          "description": "Performs a shift right logical operation on the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "bit",
          "category": "function",
          "description": "Performs a bit test operation on the specified bit of the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The index of the target bit."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "res",
          "category": "function",
          "description": "Resets the specified bit of the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The index of the target bit."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        },
        {
          "name": "set",
          "category": "function",
          "description": "Sets the specified bit of the specified register.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "A mutable reference to a `GBState` struct."
            },
            {
              "name": "n1",
              "type": "u8",
              "description": "The index of the target bit."
            },
            {
              "name": "n2",
              "type": "u8",
              "description": "The index of the target register."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example Usage",
          "description": "This example demonstrates the usage of the `op_bitwise` function to perform bitwise operations on the registers.",
          "example": "// Game Boy state initialization\nlet mut state = GBState::new();\n\n// Call the op_bitwise function\nlet result = op_bitwise(&mut state);\n\nprintln!(\"Result: {:?}\", result);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "use crate::audio::Audio;\nuse crate::consts::{BOOT_ROM_FILE, PROGRAM_START_ADDRESS, STACK_START_ADDRESS};\nuse crate::display::Display;\nuse std::fs::File;\nuse std::io::Read;\n\npub mod reg {\n    pub const B: u8 = 0;\n    pub const C: u8 = 1;\n    pub const D: u8 = 2;\n    pub const E: u8 = 3;\n    pub const H: u8 = 4;\n    pub const L: u8 = 5;\n    pub const A: u8 = 6;\n    pub const F: u8 = 7;\n\n    pub const BC: u8 = 0;\n    pub const DE: u8 = 1;\n    pub const HL: u8 = 2;\n    pub const SP: u8 = 3;\n}\n\npub mod flag {\n    pub const NZ: u8 = 0;\n    pub const Z: u8 = 1;\n    pub const NC: u8 = 2;\n    pub const C: u8 = 3;\n\n    pub const CY: u8 = 1 << 4;\n    pub const H: u8 = 1 << 5;\n    pub const N: u8 = 1 << 6;\n    pub const ZF: u8 = 1 << 7;\n}\n\n#[derive(Debug)]",
    "name": "state_chunk_0.rs",
    "path": "src/state_chunk_0.rs",
    "originalPath": "src/state_chunk_0.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file, `state_chunk_0.rs`, contains Rust code that defines constants and modules related to the game console's state and registers. It also includes a debug print statement for the `#[derive(Debug)]` attribute.\n\nThe purpose of this file is to provide a centralized location to define the constants used in the game console's state and registers. It also organizes the state-related code into separate modules to improve code organization and maintainability.\n\nThe provided code defines two modules: `reg` and `flag`. The `reg` module contains constants representing the game console's registers, such as B, C, D, etc. The `flag` module contains constants representing the game console's flags, such as NZ, Z, NC, etc.",
      "references": [
        {
          "name": "reg",
          "category": "module",
          "description": "This module defines the constants representing the game console's registers.\n\nIt includes constants for each register, such as B, C, D, etc. These constants can be used to access or manipulate the corresponding registers in the game console's state.\n\nFor example, `reg::B` represents the B register, and its value can be accessed using `reg::B`.",
          "enum": [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7"
          ],
          "publics": true
        },
        {
          "name": "flag",
          "category": "module",
          "description": "This module defines the constants representing the game console's flags.\n\nIt includes constants for each flag, such as NZ, Z, NC, etc. These constants can be used to access or manipulate the corresponding flags in the game console's state.\n\nFor example, `flag::NZ` represents the NZ flag, and its value can be accessed using `flag::NZ`.",
          "enum": [
            "0",
            "1",
            "2",
            "3"
          ],
          "publics": true
        },
        {
          "name": "reg::B",
          "category": "constant",
          "description": "This constant represents the B register in the game console's state.\n\nA register is a storage location within the game console's processor that can hold a single value. The B register is the 8-bit counterpart of the BC register pair.\n\nThe value of this constant is `0`.",
          "publics": true
        },
        {
          "name": "reg::C",
          "category": "constant",
          "description": "This constant represents the C register in the game console's state.\n\nA register is a storage location within the game console's processor that can hold a single value. The C register is the 8-bit counterpart of the BC register pair.\n\nThe value of this constant is `1`.",
          "publics": true
        },
        {
          "name": "reg::D",
          "category": "constant",
          "description": "This constant represents the D register in the game console's state.\n\nA register is a storage location within the game console's processor that can hold a single value. The D register is the 8-bit counterpart of the DE register pair.\n\nThe value of this constant is `2`.",
          "publics": true
        },
        {
          "name": "reg::E",
          "category": "constant",
          "description": "This constant represents the E register in the game console's state.\n\nA register is a storage location within the game console's processor that can hold a single value. The E register is the 8-bit counterpart of the DE register pair.\n\nThe value of this constant is `3`.",
          "publics": true
        },
        {
          "name": "reg::H",
          "category": "constant",
          "description": "This constant represents the H register in the game console's state.\n\nA register is a storage location within the game console's processor that can hold a single value. The H register is the 8-bit counterpart of the HL register pair.\n\nThe value of this constant is `4`.",
          "publics": true
        },
        {
          "name": "reg::L",
          "category": "constant",
          "description": "This constant represents the L register in the game console's state.\n\nA register is a storage location within the game console's processor that can hold a single value. The L register is the 8-bit counterpart of the HL register pair.\n\nThe value of this constant is `5`.",
          "publics": true
        },
        {
          "name": "reg::A",
          "category": "constant",
          "description": "This constant represents the A register in the game console's state.\n\nA register is a storage location within the game console's processor that can hold a single value. The A register is the 8-bit counterpart of the AF register pair.\n\nThe value of this constant is `6`.",
          "publics": true
        },
        {
          "name": "reg::F",
          "category": "constant",
          "description": "This constant represents the F register in the game console's state.\n\nA register is a storage location within the game console's processor that can hold a single value. The F register is the 8-bit counterpart of the AF register pair.\n\nThe value of this constant is `7`.",
          "publics": true
        },
        {
          "name": "reg::BC",
          "category": "constant",
          "description": "This constant represents the BC register pair in the game console's state.\n\nA register pair is a storage location within the game console's processor that can hold a 16-bit value. The BC register pair consists of the B and C registers.\n\nThe value of this constant is `0`.",
          "publics": true
        },
        {
          "name": "reg::DE",
          "category": "constant",
          "description": "This constant represents the DE register pair in the game console's state.\n\nA register pair is a storage location within the game console's processor that can hold a 16-bit value. The DE register pair consists of the D and E registers.\n\nThe value of this constant is `1`.",
          "publics": true
        },
        {
          "name": "reg::HL",
          "category": "constant",
          "description": "This constant represents the HL register pair in the game console's state.\n\nA register pair is a storage location within the game console's processor that can hold a 16-bit value. The HL register pair consists of the H and L registers.\n\nThe value of this constant is `2`.",
          "publics": true
        },
        {
          "name": "reg::SP",
          "category": "constant",
          "description": "This constant represents the SP register pair in the game console's state.\n\nA register pair is a storage location within the game console's processor that can hold a 16-bit value. The SP register pair consists of the stack pointer.\n\nThe value of this constant is `3`.",
          "publics": true
        },
        {
          "name": "flag::NZ",
          "category": "constant",
          "description": "This constant represents the NZ flag in the game console's flags.\n\nThe NZ flag indicates the result of the previous arithmetic or logical operation is non-zero. It is the 0th flag in the flag register.\n\nThe value of this constant is `0`.",
          "publics": true
        },
        {
          "name": "flag::Z",
          "category": "constant",
          "description": "This constant represents the Z flag in the game console's flags.\n\nThe Z flag indicates the result of the previous arithmetic or logical operation is zero. It is the 1st flag in the flag register.\n\nThe value of this constant is `1`.",
          "publics": true
        },
        {
          "name": "flag::NC",
          "category": "constant",
          "description": "This constant represents the NC flag in the game console's flags.\n\nThe NC flag indicates there was no carry in the last arithmetic or logical operation. It is the 2nd flag in the flag register.\n\nThe value of this constant is `2`.",
          "publics": true
        },
        {
          "name": "flag::C",
          "category": "constant",
          "description": "This constant represents the C flag in the game console's flags.\n\nThe C flag indicates there was a carry in the last arithmetic or logical operation. It is the 3rd flag in the flag register.\n\nThe value of this constant is `3`.",
          "publics": true
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "This example demonstrates the usage of the `reg::B` constant.",
          "example": "fn main() {\n    let b = reg::B;\n    println!(\"B register: {}\", b);\n}",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "This example demonstrates the usage of the `flag::Z` constant.",
          "example": "fn main() {\n    let z = flag::Z;\n    println!(\"Z flag: {}\", z);\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub struct CPU {\n    /* B, C, D, E, H, L, A, F registers.\n     * A is usually represented by 111 even though it's in index 6.\n     * (HL) usually takes the 110 representation.\n     * F isn't usually used by the 8bits register operations. */\n    pub r: [u8; 8],\n\n    pub pc: u16, // program counter\n    pub sp: u16, // stack pointer\n}",
    "name": "state_chunk_1.rs",
    "path": "src/state_chunk_1.rs",
    "originalPath": "src/state_chunk_1.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file defines a struct `CPU` that represents the state of a central processing unit. It contains an array `r` of size 8 representing the B, C, D, E, H, L, A, and F registers. The `pc` field represents the program counter, and the `sp` field represents the stack pointer.",
      "references": [
        {
          "name": "CPU",
          "category": "struct",
          "description": "A struct representing the state of a CPU. It contains the registers B, C, D, E, H, L, A, F, program counter (`pc`), and stack pointer (`sp`).",
          "parameters": [],
          "returns": null,
          "publics": true
        },
        {
          "name": "r",
          "category": "method",
          "description": "Accesses the array of registers `r`.",
          "parameters": [],
          "returns": {
            "type": "[u8; 8]",
            "description": "The array of registers."
          },
          "publics": true
        },
        {
          "name": "pc",
          "category": "method",
          "description": "Accesses the program counter (`pc`).",
          "parameters": [],
          "returns": {
            "type": "u16",
            "description": "The program counter."
          },
          "publics": true
        },
        {
          "name": "sp",
          "category": "method",
          "description": "Accesses the stack pointer (`sp`).",
          "parameters": [],
          "returns": {
            "type": "u16",
            "description": "The stack pointer."
          },
          "publics": true
        }
      ],
      "examples": [
        {
          "title": "Accessing registers",
          "description": "An example of accessing the `r` array of registers.",
          "example": "let cpu = CPU { r: [0; 8], pc: 0, sp: 0 };  // Create a new CPU\nlet registers = cpu.r;  // Access the `r` array\nprintln!(\"registers: {:?}\", registers);  // Print the registers",
          "example_markdown_language": "rust"
        },
        {
          "title": "Accessing program counter",
          "description": "An example of accessing the program counter (`pc`).",
          "example": "let cpu = CPU { r: [0; 8], pc: 0, sp: 0 };  // Create a new CPU\nlet program_counter = cpu.pc;  // Access the `pc`\nprintln!(\"program counter: {:?}\", program_counter);  // Print the program counter",
          "example_markdown_language": "rust"
        },
        {
          "title": "Accessing stack pointer",
          "description": "An example of accessing the stack pointer (`sp`).",
          "example": "let cpu = CPU { r: [0; 8], pc: 0, sp: 0 };  // Create a new CPU\nlet stack_pointer = cpu.sp;  // Access the `sp`\nprintln!(\"stack pointer: {:?}\", stack_pointer);  // Print the stack pointer",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "impl CPU {\n    pub fn new() -> Self {\n        Self {\n            r: [0; 8],\n\n            pc: PROGRAM_START_ADDRESS,\n            sp: STACK_START_ADDRESS,\n        }\n    }\n\n    pub fn r16(&self, r: u8) -> u16 {\n        if r == reg::SP {\n            return self.sp;\n        } else {\n            return self.r[r as usize * 2 + 1] as u16 | ((self.r[r as usize * 2] as u16) << 8);\n        }\n    }\n\n    pub fn w16(&mut self, r: u8, value: u16) {\n        if r == reg::SP {\n            self.sp = value;\n        } else {\n            self.r[r as usize * 2 + 1] = (value & 0xff) as u8;\n            self.r[r as usize * 2] = (value >> 8) as u8;\n        }\n    }\n\n    pub fn check_flag(&self, flag: u8) -> bool {\n        let f = self.r[reg::F as usize];",
    "name": "state_chunk_2.rs",
    "path": "src/state_chunk_2.rs",
    "originalPath": "src/state_chunk_2.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "The provided code defines methods for a CPU struct in Rust. The CPU struct has various methods for manipulating registers and flags. The 'new' method initializes a new CPU struct with default values for the registers, program counter (pc), and stack pointer (sp). The 'r16' method takes an 8-bit register as an argument and returns the corresponding 16-bit value. If the register is the stack pointer (SP), it returns the value of the stack pointer. Otherwise, it returns the value formed by combining the lower and upper bytes of the register. The 'w16' method takes an 8-bit register and a 16-bit value as arguments and sets the corresponding register with the specified value. If the register is the stack pointer (SP), it updates the stack pointer with the given value. Otherwise, it splits the 16-bit value into lower and upper bytes and stores them in the appropriate registers. The 'check_flag' method takes an 8-bit flag as an argument and returns a boolean indicating whether the flag is set or not. The method accesses the flag register (F) and checks if the specified flag is set. The provided code also defines an enum 'reg' that is used to specify various registers and flag values.",
      "references": [
        {
          "name": "new",
          "category": "method",
          "description": "Initializes a new CPU struct with default register, program counter, and stack pointer values.",
          "parameters": [],
          "returns": {
            "type": "Self",
            "description": "A CPU struct with initialized values."
          }
        },
        {
          "name": "r16",
          "category": "method",
          "description": "Returns the 16-bit value of the specified register.",
          "parameters": [
            {
              "name": "r",
              "type": "u8",
              "description": "The 8-bit register."
            }
          ],
          "returns": {
            "type": "u16",
            "description": "The 16-bit value of the register."
          }
        },
        {
          "name": "w16",
          "category": "method",
          "description": "Sets the value of the specified register.",
          "parameters": [
            {
              "name": "r",
              "type": "u8",
              "description": "The 8-bit register."
            },
            {
              "name": "value",
              "type": "u16",
              "description": "The 16-bit value to set."
            }
          ],
          "returns": null
        },
        {
          "name": "check_flag",
          "category": "method",
          "description": "Checks if the specified flag is set.",
          "parameters": [
            {
              "name": "flag",
              "type": "u8",
              "description": "The 8-bit flag to check."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "True if the flag is set, false otherwise."
          }
        }
      ],
      "examples": [
        {
          "title": "Initializing a CPU",
          "description": "Create a new CPU struct with default values.",
          "example": "let cpu = CPU::new();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Getting the value of a register",
          "description": "Get the 16-bit value of register R1.",
          "example": "let value = cpu.r16(reg::R1);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Setting the value of a register",
          "description": "Set the value of register R2 to 0x1234.",
          "example": "cpu.w16(reg::R2, 0x1234);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Checking a flag",
          "description": "Check if the carry flag is set.",
          "example": "let is_carry_set = cpu.check_flag(flag::CARRY);",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "match flag {\n            flag::NZ => f >> 7 == 0,\n            flag::Z => f >> 7 == 1,\n            flag::NC => f >> 4 == 0,\n            flag::C => f >> 4 == 1,\n            _ => unimplemented!(),\n        }\n    }\n}",
    "name": "state_chunk_3.rs",
    "path": "src/state_chunk_3.rs",
    "originalPath": "src/state_chunk_3.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file, src/state_chunk_3.rs, contains code that checks the value of a flag by performing bitwise operations. It uses a match statement to check the different possible flag values and returns a boolean based on the result of the bitwise operation. The purpose of this code is to determine the state of a specific flag based on its binary representation in a register. If the flag value matches the expected binary value, it returns true; otherwise, it returns false.",
      "references": [
        {
          "name": "state_check",
          "category": "function",
          "description": "This function checks the value of a flag by performing bitwise operations.",
          "errors": [
            {
              "name": "unimplemented",
              "description": "This error occurs when the match arm for a specific flag is not implemented. This can happen if there are additional flag values that are not handled in the match statement."
            }
          ],
          "parameters": [
            {
              "name": "flag",
              "type": "Flag",
              "description": "The flag value to check."
            },
            {
              "name": "f",
              "type": "u8",
              "description": "The register containing the flag value."
            }
          ],
          "returns": {
            "type": "bool",
            "description": "A boolean value indicating whether the flag value matches the expected binary value."
          },
          "prototype": "fn state_check(flag: Flag, f: u8) -> bool;"
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Check if a flag value matches the expected binary value.",
          "example": "// Example usage of state_check function\nlet flag_value = flag::NZ;\nlet register_value = 0b10000000;\nlet result = state_check(flag_value, register_value);\nprintln!(\"Flag value matches expected binary: {}\", result);",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "Handle the unimplemented match arm error.",
          "example": "// Example usage of state_check function with unimplemented match arm\nlet flag_value = flag::Unknown;\nlet register_value = 0b10101010;\n\nmatch state_check(flag_value, register_value) {\n    true => println!(\"Flag value matches expected binary.\"),\n    false => println!(\"Flag value does not match expected binary.\"),\n    _ => panic!(\"Unimplemented match arm.\"),\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub struct Memory {\n    boot_rom: [u8; 0x100],\n    pub boot_rom_on: bool,\n\n    // 32 KiB ROM bank 00\n    rom: [u8; 0x8000],\n\n    // 4 KiB Work RAM 00\n    wram_00: [u8; 0x1000],\n\n    // 4 KiB Work RAM 00\n    wram_01: [u8; 0x1000],\n\n    // 8 KiB Video RAM\n    pub display: Display,\n\n    pub io: [u8; 0x80],\n\n    // High RAM\n    hram: [u8; 0x7f],\n\n    pub audio: Audio,\n\n    pub ime: bool,\n\n    pub interrupts_register: u8,\n}\n\n#[derive(Debug)]\npub enum MemError {\n    WritingToROM,\n    Unimplemented,\n    NotUsable,\n}",
    "name": "state_chunk_4.rs",
    "path": "src/state_chunk_4.rs",
    "originalPath": "src/state_chunk_4.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file defines the struct `Memory` which represents the memory system of a Game Boy. It contains various memory sections such as the boot ROM, ROM bank, work RAM, video RAM, IO registers, high RAM, audio registers, and interrupt enable register. The file also defines an enum `MemError` which lists the possible errors that can occur while accessing memory.",
      "references": [
        {
          "name": "Memory",
          "category": "structure",
          "description": "The `Memory` struct represents the memory system of a Game Boy. It contains various memory sections such as the boot ROM, ROM bank, work RAM, video RAM, IO registers, high RAM, audio registers, and interrupt enable register.",
          "publics": true,
          "parameters": [],
          "returns": null
        },
        {
          "name": "MemError",
          "category": "enum",
          "description": "The `MemError` enum lists the possible errors that can occur while accessing memory.",
          "publics": false,
          "returns": null,
          "enum": [
            "WritingToROM",
            "Unimplemented",
            "NotUsable"
          ]
        }
      ],
      "examples": [
        {
          "title": "Creating a Memory instance",
          "description": "This example demonstrates how to create a new instance of the `Memory` struct.",
          "example": "let memory = Memory { boot_rom: [0; 0x100], boot_rom_on: false, rom: [0; 0x8000], wram_00: [0; 0x1000], wram_01: [0; 0x1000], display: Display::new(), io: [0; 0x80], hram: [0; 0x7f], audio: Audio::new(), ime: false, interrupts_register: 0 };",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "impl Memory {\n    pub fn new() -> Self {\n        let mut display = Display::new();\n\n        display.cls();\n\n        Self {\n            boot_rom: [0; 0x100],\n            boot_rom_on: true,\n            rom: [0; 0x8000],\n            wram_00: [0; 0x1000],\n            wram_01: [0; 0x1000],\n            display,\n            io: [0; 0x80],\n            hram: [0; 0x7f],\n            audio: Audio::new(),\n            ime: false,\n            interrupts_register: 0,\n        }\n    }\n\n    pub fn load_boot_rom(&mut self) -> Result<(), std::io::Error> {\n        let mut f = File::open(BOOT_ROM_FILE)?;\n\n        f.read(&mut self.boot_rom)?;\n\n        Ok(())\n    }\n\n    pub fn load_rom(&mut self, file: &str) -> Result<(), std::io::Error> {\n        let mut f = File::open(file)?;\n\n        f.read(&mut self.rom)?;",
    "name": "state_chunk_5.rs",
    "path": "src/state_chunk_5.rs",
    "originalPath": "src/state_chunk_5.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file `src/state_chunk_5.rs` defines various functions for initializing and manipulating the memory of a computer system. It includes a `Memory` struct, along with methods for creating a new instance of `Memory`, loading the boot ROM, and loading the main ROM. The `Memory` struct contains fields for storing boot ROM data, main ROM data, working RAM, display and audio information, IO registers, and interrupt-related data. The methods in this file allow for initializing the memory and loading ROM data from files. The file also includes error handling for file I/O operations.",
      "references": [
        {
          "name": "Memory::new",
          "category": "method",
          "description": "Creates a new instance of `Memory` with default values for all fields.",
          "parameters": [],
          "returns": {
            "type": "Memory",
            "description": "The newly created `Memory` instance."
          }
        },
        {
          "name": "Memory::load_boot_rom",
          "category": "method",
          "description": "Loads the boot ROM data from a file into the `boot_rom` field of `Memory`.",
          "parameters": [],
          "returns": {
            "type": "Result<(), std::io::Error>",
            "description": "A `Result` indicating whether the boot ROM was loaded successfully or if an error occurred."
          },
          "errors": [
            {
              "name": "std::io::Error",
              "description": "An error that occurred during file I/O operations."
            }
          ]
        },
        {
          "name": "Memory::load_rom",
          "category": "method",
          "description": "Loads the main ROM data from a file into the `rom` field of `Memory`.",
          "parameters": [
            {
              "name": "file",
              "type": "&str",
              "description": "The path to the ROM file to load."
            }
          ],
          "returns": {
            "type": "Result<(), std::io::Error>",
            "description": "A `Result` indicating whether the main ROM was loaded successfully or if an error occurred."
          },
          "errors": [
            {
              "name": "std::io::Error",
              "description": "An error that occurred during file I/O operations."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example 1: Creating a new Memory instance",
          "description": "Create a new instance of `Memory` using the `Memory::new` method.",
          "example": "let memory = Memory::new();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2: Loading the boot ROM",
          "description": "Load the boot ROM data into the `Memory` instance using the `Memory::load_boot_rom` method.",
          "example": "# Make sure to replace '<root>' with the actual root directory path\n\nrust -m <base_command> src/state_chunk_5.rs --load-boot-rom <root>/path/to/boot_rom.bin",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example 3: Loading the main ROM",
          "description": "Load the main ROM data into the `Memory` instance using the `Memory::load_rom` method.",
          "example": "# Make sure to replace '<root>' with the actual root directory path\n\nrust -m <base_command> src/state_chunk_5.rs --load-rom <root>/path/to/main_rom.bin",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "Ok(())\n    }",
    "name": "state_chunk_6.rs",
    "path": "src/state_chunk_6.rs",
    "originalPath": "src/state_chunk_6.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "The provided content from file src/state_chunk_6.rs is a Rust code snippet that returns Ok(()) and terminates the program successfully. The main purpose of this code is to represent a successful execution of a Rust program without any errors or exceptions.",
      "references": [
        {
          "name": "main",
          "category": "function",
          "description": "The main function is the entry point of a Rust program. It is responsible for starting the execution of the program and terminating it when done. In this case, the main function returns Ok(()) to indicate a successful program termination.",
          "returns": {
            "type": "Result<(), ()>",
            "description": "Ok(()) is returned to indicate a successful program termination without any errors."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "A simple example that demonstrates the successful termination of a Rust program.",
          "example": "// main.rs\nfn main() {\n    Ok(())\n}",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example 2",
          "description": "A commented bash program that shows how to compile and run the Rust program.",
          "example": "# Compile the Rust program\n$ cargo build\n\n# Run the program\n$ cargo run",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn r(&self, addr: u16) -> Result<u8, MemError> {\n        if addr < 0x100 && self.boot_rom_on {\n            Ok(self.boot_rom[addr as usize])\n        } else if addr < 0x8000 {\n            Ok(self.rom[addr as usize])\n        } else if addr >= 0xc000 && addr < 0xd000 {\n            Ok(self.wram_00[addr as usize - 0xc000])\n        } else if addr >= 0xd000 && addr < 0xe000 {\n            Ok(self.wram_01[addr as usize - 0xd000])\n        } else if addr >= 0x8000 && addr < 0xa000 {\n            self.display.r(addr & !0x8000)\n        } else if addr >= 0xff00 && addr < 0xff80 {\n            Ok(self.r_io((addr & 0xff) as u8))\n        } else if addr >= 0xff80 && addr < 0xffff {\n            Ok(self.hram[addr as usize - 0xff80])\n        } else if addr == 0xffff {",
    "name": "state_chunk_7.rs",
    "path": "src/state_chunk_7.rs",
    "originalPath": "src/state_chunk_7.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "The provided code snippet is from the file `src/state_chunk_7.rs` and contains a function `r` that retrieves a value from different memory regions based on the specified address. The function takes an `addr` argument of type `u16` and returns a `Result<u8, MemError>` where `u8` represents the retrieved value and `MemError` represents any errors that may occur during the retrieval. The function first checks if the `addr` falls within the range of the boot ROM (`0x0000-0x00FF`) and if the boot ROM is enabled. If true, it retrieves the value from the boot ROM array. If false, it proceeds to check other memory regions and returns the respective values stored at the corresponding addresses.",
      "references": [
        {
          "name": "r",
          "category": "method",
          "description": "Retrieves a value from different memory regions based on the specified address.",
          "errors": [
            {
              "name": "MemError",
              "description": "Represents errors that can occur during memory retrieval."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u16",
              "description": "The address from which to retrieve the value."
            }
          ],
          "returns": {
            "type": "Result<u8, MemError>",
            "description": "The retrieved value if successful, otherwise an error."
          }
        }
      ],
      "examples": [
        {
          "title": "Example 1",
          "description": "Retrieve a value from memory using the `r` function.",
          "example": "let result = r(&self, 0x8123);\n// result: Ok(value) or Err(error)",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "Ok(self.interrupts_register)\n        } else {\n            // println!(\n            //     \"Trying to read at address 0x{:04x} which is unimplemented\",\n            //     addr\n            // );\n            Ok(0) //Err(MemError::Unimplemented)\n        }\n    }",
    "name": "state_chunk_8.rs",
    "path": "src/state_chunk_8.rs",
    "originalPath": "src/state_chunk_8.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file, `src/state_chunk_8.rs`, contains the implementation of a function. The function takes an address as input and returns the corresponding value if it exists in the interrupt register. Otherwise, it returns 0. The function also handles the case where the address is unimplemented and throws an error. This file is used as a part of a larger Rust project for handling interrupts and memory operations.",
      "references": [
        {
          "name": "read_interrupt_register",
          "category": "function",
          "description": "This function reads the value from the interrupt register corresponding to the given address.",
          "errors": [
            {
              "name": "MemError::Unimplemented",
              "description": "This error occurs when attempting to read from an unimplemented address in the interrupt register."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u16",
              "description": "The address from which to read the interrupt register."
            }
          ],
          "returns": {
            "type": "Result<u16, MemError>",
            "description": "If the address exists in the interrupt register, the corresponding value is returned. Otherwise, an error of type `MemError::Unimplemented` is returned."
          },
          "prototype": "fn read_interrupt_register(&self, addr: u16) -> Result<u16, MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example usage of `read_interrupt_register`",
          "description": "This example demonstrates the usage of the `read_interrupt_register` function.",
          "example": "// Import the required module or crate if necessary\n// use crate::module_name::state_chunk_8::read_interrupt_register;\n\nfn main() {\n    let addr: u16 = 0xABCD;\n\n    // Call the function to read the interrupt register\n    match read_interrupt_register(addr) {\n        Ok(value) => println!(\"Value from interrupt register: {:?}\", value),\n        Err(err) => println!(\"Error occurred: {:?}\", err),\n    }\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn w(&mut self, addr: u16, value: u8) -> Result<(), MemError> {\n        if addr < 0x100 && self.boot_rom_on {\n            self.boot_rom[addr as usize] = value;\n            Ok(())\n        } else if addr < 0x8000 {\n            self.rom[addr as usize] = value;\n            Ok(())\n        } else if addr >= 0xc000 && addr < 0xd000 {\n            self.wram_00[addr as usize - 0xc000] = value;\n            Ok(())\n        } else if addr >= 0xd000 && addr < 0xe000 {\n            self.wram_01[addr as usize - 0xd000] = value;\n            Ok(())\n        } else if addr >= 0x8000 && addr < 0xa000 {\n            self.display.w(addr & !0x8000, value)\n        } else if addr >= 0xff00 && addr < 0xff80 {\n            Ok(self.w_io((addr & 0xff) as u8, value))",
    "name": "state_chunk_9.rs",
    "path": "src/state_chunk_9.rs",
    "originalPath": "src/state_chunk_9.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file contains the implementation of a Rust structure called `state_chunk_9`. The `state_chunk_9` structure has a method named `w` which is used to write a value to different memory addresses. The method accepts an `addr` of type `u16` and a `value` of type `u8`. The `w` method has several conditions to determine where the value should be written based on the address. If the `addr` is less than 0x100 and the `boot_rom_on` flag is enabled, the value will be written to the `boot_rom` at the corresponding index. If the `addr` is less than 0x8000, the value will be written to the `rom` at the corresponding index. If the `addr` is between 0xc000 and 0xd000, the value will be written to `wram_00` at the corresponding index. If the `addr` is between 0xd000 and 0xe000, the value will be written to `wram_01` at the corresponding index. If the `addr` is between 0x8000 and 0xa000, the `w` method calls the `w` method of the `display` structure with the modified address and value. If the `addr` is between 0xff00 and 0xff80, the `w_io` method is called with the modified address and value.",
      "references": [
        {
          "name": "w",
          "category": "method",
          "description": "Writes a value to the specified memory address based on various conditions.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that may occur if an invalid memory address is provided."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u16",
              "description": "The memory address to write the value to."
            },
            {
              "name": "value",
              "type": "u8",
              "description": "The value to be written."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A result indicating success or an error."
          }
        }
      ],
      "examples": [
        {
          "title": "Example: Writing a value with `w` method",
          "description": "This example demonstrates the usage of the `w` method to write a value to a memory address.",
          "example": "// Setting up the `state_chunk_9` instance\nlet mut state = state_chunk_9::StateChunk9::new();\n\n// Writing value 42 to address 0x1234\nstate.w(0x1234, 42);\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "} else if addr >= 0xff80 && addr < 0xffff {\n            self.hram[addr as usize - 0xff80] = value;\n            Ok(())\n        } else if addr == 0xffff {\n            self.interrupts_register = value;\n            Ok(())\n        } else {\n            // println!(\n            //     \"Trying to write at address 0x{:04x} which is unimplemented\",\n            //     addr\n            // );\n            Ok(()) //Err(MemError::Unimplemented)\n        }\n    }\n}",
    "name": "state_chunk_10.rs",
    "path": "src/state_chunk_10.rs",
    "originalPath": "src/state_chunk_10.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file contains the code for the `state_chunk_10` module in the project. It defines a function that examines the provided content and writes values to specific memory addresses. The function handles different memory address ranges and updates the corresponding memory locations accordingly. If the provided address falls within a specific range, the function writes the value to the corresponding memory location. If it falls outside any known range, it returns an 'Unimplemented' error. The file also contains commented code showing an example of how to use the function.",
      "references": [
        {
          "name": "write_to_memory",
          "category": "function",
          "description": "Writes a value to a memory address.",
          "errors": [
            {
              "name": "Unimplemented",
              "description": "The provided address is not implemented."
            }
          ],
          "parameters": [
            {
              "name": "addr",
              "type": "u16",
              "description": "The memory address to write to."
            },
            {
              "name": "value",
              "type": "u8",
              "description": "The value to write to the memory address."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A result indicating success or failure and an optional MemError if an error occurs."
          },
          "prototype": "fn write_to_memory(&mut self, addr: u16, value: u8) -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Writing to Memory",
          "description": "An example of how to use the `write_to_memory` function to write a value to a memory address.",
          "example": "state_chunk_10::write_to_memory(&mut state, 0xff82, 0x0A)?;",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub struct GBState {\n    pub cpu: CPU,\n    pub mem: Memory,\n}",
    "name": "state_chunk_11.rs",
    "path": "src/state_chunk_11.rs",
    "originalPath": "src/state_chunk_11.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file defines the `GBState` struct which represents the state of a Game Boy console. It contains two public fields: `cpu` of type `CPU` and `mem` of type `Memory`.",
      "references": [
        {
          "name": "GBState",
          "category": "struct",
          "description": "Represents the state of a Game Boy console.",
          "publics": true,
          "parameters": [],
          "returns": null
        },
        {
          "name": "cpu",
          "category": "field",
          "description": "Represents the central processing unit of the Game Boy.",
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "CPU",
            "description": "The CPU object."
          }
        },
        {
          "name": "mem",
          "category": "field",
          "description": "Represents the memory of the Game Boy.",
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "Memory",
            "description": "The Memory object."
          }
        }
      ],
      "examples": [
        {
          "title": "Example",
          "description": "Create a Game Boy state with a CPU and memory.",
          "example": "let cpu = CPU::new();\nlet mem = Memory::new();\nlet gb_state = GBState { cpu, mem };",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "impl GBState {\n    pub fn new() -> Self {\n        let mut mem = Memory::new();\n\n        mem.load_boot_rom().unwrap();\n\n        Self {\n            cpu: CPU::new(),\n            mem,\n        }\n    }\n\n    pub fn r_reg(&self, r_i: u8) -> Result<u8, MemError> {\n        if r_i < 6 {\n            Ok(self.cpu.r[r_i as usize])\n        } else if r_i == 7 {\n            Ok(self.cpu.r[6])\n        } else if r_i == 6 {\n            self.mem.r(self.cpu.r16(reg::HL))\n        } else {\n            panic!(\"r_i must be a 3 bits register input number\")\n        }\n    }",
    "name": "state_chunk_12.rs",
    "path": "src/state_chunk_12.rs",
    "originalPath": "src/state_chunk_12.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file defines the implementation of the GBState struct and its associated functions. The GBState struct represents the state of the Game Boy system and provides functions to create a new state instance, read register values, and handle memory operations.",
      "references": [
        {
          "name": "new",
          "category": "method",
          "description": "Creates a new instance of the GBState struct with initialized CPU and Memory.",
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "GBState",
            "description": "The newly created GBState instance."
          },
          "prototype": "pub fn new() -> Self"
        },
        {
          "name": "r_reg",
          "category": "method",
          "description": "Reads the value from a register of the CPU or memory using the specified register index.",
          "publics": true,
          "parameters": [
            {
              "name": "r_i",
              "type": "u8",
              "description": "The register index."
            }
          ],
          "returns": {
            "type": "Result<u8, MemError>",
            "description": "The value read from the register if successful, or an error if the register index is invalid or out of range."
          },
          "prototype": "pub fn r_reg(&self, r_i: u8) -> Result<u8, MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example: Create a new GBState instance",
          "description": "This example demonstrates how to create a new instance of the GBState struct.",
          "example": "use my_crate::GBState;\n\nfn main() {\n    let state = GBState::new();\n    // Use the created state\n}\n",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example: Read register value",
          "description": "This example shows how to read the value from a register in the GBState instance.",
          "example": "fn main() {\n    let state = GBState::new();\n    match state.r_reg(3) {\n        Ok(value) => println!(\"Register value: {}\", value),\n        Err(err) => eprintln!(\"Failed to read register: {:?}\", err),\n    }\n}\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "pub fn w_reg(&mut self, r_i: u8, value: u8) -> Result<(), MemError> {\n        if r_i < 6 {\n            self.cpu.r[r_i as usize] = value;\n        } else if r_i == 7 {\n            self.cpu.r[6] = value;\n        } else if r_i == 6 {\n            self.mem.w(self.cpu.r16(reg::HL), value)?;\n        } else {\n            panic!(\"r_i must be a 3 bits register input number\")\n        }\n        Ok(())\n    }\n}",
    "name": "state_chunk_13.rs",
    "path": "src/state_chunk_13.rs",
    "originalPath": "src/state_chunk_13.rs",
    "chunkTotal": 14,
    "reference_json": {
      "description": "This file contains a Rust module with a function called `w_reg` that allows writing a value to a register of a CPU. The function takes two arguments, `r_i` and `value`, where `r_i` specifies the register number and `value` is the value to be written. The function handles different cases based on the value of `r_i`. If `r_i` is less than 6, it writes the value to the corresponding register in the `cpu` struct. If `r_i` is 7, it writes the value to register 6, and if `r_i` is 6, it writes the value to the memory location specified by the register value in the `cpu` struct. Otherwise, it panics with an error message. The function returns a `Result` indicating success or an error of type `MemError`.",
      "references": [
        {
          "name": "w_reg",
          "category": "method",
          "description": "Writes the given value to a register or memory based on the specified register number.",
          "parameters": [
            {
              "name": "r_i",
              "type": "u8",
              "description": "The register number."
            },
            {
              "name": "value",
              "type": "u8",
              "description": "The value to be written."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A `Result` indicating success or an error of type `MemError`."
          }
        }
      ],
      "examples": [
        {
          "title": "Example usage of w_reg function",
          "description": "Writes a value to a register using the `w_reg` function.",
          "example": "let mut state = State::new();\nstate.w_reg(3, 10).unwrap();",
          "example_markdown_language": "rust"
        },
        {
          "title": "Example panic with invalid register number",
          "description": "Demonstrates a panic caused by an invalid register number.",
          "example": "let mut state = State::new();\nstate.w_reg(8, 5);\n// Output: panicked at 'r_i must be a 3 bits register input number'",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "use crate::exec_opcode;\nuse crate::state::{flag, reg, GBState, MemError};\n\n#[test]\nfn test_ldrr() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b01000001)?; // Opcode for LD B, C\n    state.cpu.r[reg::C as usize] = 42;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::B as usize], 42);\n    Ok(())\n}\n\n#[test]\nfn test_ldr8() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00000110)?; // Opcode for LD B, n\n    state.mem.w(1, 0x42)?; // n = 0x42\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::B as usize], 0x42);\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_0.rs",
    "path": "src/tests/instructions_tests_chunk_0.rs",
    "originalPath": "src/tests/instructions_tests_chunk_0.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains test cases for the `exec_opcode` function in the `state` module. It tests two functions: `test_ldrr` and `test_ldr8`. Each test case initializes a `GBState` object, sets up the memory with the corresponding opcode and value, calls `exec_opcode`, and asserts the expected result. These tests ensure that the `exec_opcode` function correctly executes the opcode instructions for loading register values.",
      "references": [
        {
          "name": "test_ldrr",
          "category": "function",
          "description": "Tests the `exec_opcode` function for loading register values using an opcode instruction.",
          "errors": [
            {
              "name": "Result",
              "description": "An error that occurs when an operation fails."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "()",
            "description": "Returns `Ok(())` if the test passes successfully."
          },
          "prototype": "fn test_ldrr() -> Result<(), MemError>"
        },
        {
          "name": "test_ldr8",
          "category": "function",
          "description": "Tests the `exec_opcode` function for loading a value into a register using an opcode instruction.",
          "errors": [
            {
              "name": "Result",
              "description": "An error that occurs when an operation fails."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "()",
            "description": "Returns `Ok(())` if the test passes successfully."
          },
          "prototype": "fn test_ldr8() -> Result<(), MemError>"
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes an opcode instruction based on the provided `GBState` object.",
          "errors": [
            {
              "name": "Result",
              "description": "An error that occurs when an operation fails."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "The `GBState` object representing the current state of the Game Boy."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the instruction is executed successfully."
          },
          "prototype": "fn exec_opcode(&mut state: GBState) -> Result<(), MemError>"
        },
        {
          "name": "GBState",
          "category": "struct",
          "description": "Represents the current state of the Game Boy.",
          "parameters": [],
          "publics": true,
          "subreferences": [
            {
              "name": "new",
              "category": "method",
              "description": "Creates a new `GBState` object with default values.",
              "keywords": [
                "create",
                "initialize"
              ]
            },
            {
              "name": "mem",
              "category": "method",
              "description": "Returns a mutable reference to the `Mem` object associated with the `GBState` object.",
              "keywords": [
                "memory"
              ]
            },
            {
              "name": "cpu",
              "category": "method",
              "description": "Returns a mutable reference to the `CPU` object associated with the `GBState` object.",
              "keywords": [
                "central processing unit"
              ]
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Example for test_ldrr",
          "description": "This example demonstrates how to use the `test_ldrr` function.",
          "example": "cargo test -- --test-threads=1 test_ldrr",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example for test_ldr8",
          "description": "This example demonstrates how to use the `test_ldr8` function.",
          "example": "cargo test -- --test-threads=1 test_ldr8",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example for exec_opcode",
          "description": "This example demonstrates how to use the `exec_opcode` function.",
          "example": "This code snippet demonstrates how to use the `exec_opcode` function to execute an opcode instruction:\n\n```rust\nuse crate::state::GBState;\nuse crate::state::MemError;\n\nfn main() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b01000001)?; // Opcode for LD B, C\n    state.cpu.r[2] = 42; // Set register C\n    state.exec_opcode()?.unwrap();\n    assert_eq!(state.cpu.r[1], 42); // Check register B\n    Ok(())\n}\n```",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_ldrr16() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00000001)?; // Opcode for LD BC, nn\n    state.mem.w(1, 0x34)?; // nn lower byte = 0x34\n    state.mem.w(2, 0x12)?; // nn higher byte = 0x12\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r16(reg::B), 0x1234);\n    Ok(())\n}\n\n#[test]\nfn test_ldnnsp() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00001000)?; // Opcode for LD (nn), SP\n    state.mem.w(1, 0x34)?; // nn lower byte = 0x34\n    state.mem.w(2, 0x12)?; // nn higher byte = 0x12\n    state.cpu.sp = 0x5678; // SP = 0x5678\n    exec_opcode(&mut state)?;\n    assert_eq!(state.mem.r(0x1234)?, 0x78); // SP low\n    assert_eq!(state.mem.r(0x1235)?, 0x56); // SP high\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_1.rs",
    "path": "src/tests/instructions_tests_chunk_1.rs",
    "originalPath": "src/tests/instructions_tests_chunk_1.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains test functions for the instructions in a Game Boy emulator. The two functions included are `test_ldrr16` and `test_ldnnsp`. The `test_ldrr16` function tests the LD (load) opcode for loading a 16-bit immediate value into a register pair. It creates a new game state, writes the opcode and the immediate value to memory, executes the opcode, and asserts that the register pair contains the correct value. The `test_ldnnsp` function tests the LD opcode for loading the stack pointer (SP) to memory. It creates a new game state, writes the opcode and memory address to memory, sets the SP register to a specific value, executes the opcode, and asserts that the memory contains the correct value.",
      "references": [
        {
          "name": "test_ldrr16",
          "category": "function",
          "description": "Tests the LD opcode for loading a 16-bit immediate value into a register pair.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs when there is a memory access violation."
            }
          ],
          "keywords": [
            "load",
            "opcode",
            "16-bit",
            "immediate",
            "value",
            "register",
            "pair"
          ],
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the test passes, otherwise returns an error."
          },
          "prototype": "fn test_ldrr16() -> Result<(), MemError>"
        },
        {
          "name": "test_ldnnsp",
          "category": "function",
          "description": "Tests the LD opcode for loading the stack pointer (SP) to memory.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs when there is a memory access violation."
            }
          ],
          "keywords": [
            "load",
            "opcode",
            "stack",
            "pointer",
            "memory"
          ],
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the test passes, otherwise returns an error."
          },
          "prototype": "fn test_ldnnsp() -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example usage of test_ldrr16",
          "description": "Tests the LD opcode for loading a 16-bit immediate value into a register pair.",
          "example": "cargo test test_ldrr16",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example usage of test_ldnnsp",
          "description": "Tests the LD opcode for loading the stack pointer (SP) to memory.",
          "example": "cargo test test_ldnnsp",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_jr8() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00011000)?; // Opcode for JR n\n    state.mem.w(1, 0x05)?; // n = 5\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.pc, 0x07); // PC is incremented by n (5) and the size of the instruction itself (2)\n    Ok(())\n}\n\n#[test]\nfn test_jrcc8() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00100000)?; // Opcode for JR NZ, n (NZ is used for simplicity)\n    state.mem.w(1, 0x05)?; // n = 5\n    state.cpu.r[reg::F as usize] = 0; // Zero flag = 0, meaning NZ (not zero) is true\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.pc, 0x07); // PC is incremented by n (5) and the size of the instruction itself (2)\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_2.rs",
    "path": "src/tests/instructions_tests_chunk_2.rs",
    "originalPath": "src/tests/instructions_tests_chunk_2.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains test cases for the instructions defined in the chunk 2 of the tests module. It tests the functionality of the JR and JRCC8 instructions. It creates a GBState object, writes opcodes and values into memory, sets the required flags, and executes the opcode. It then asserts that the program counter (PC) is incremented correctly.",
      "references": [
        {
          "name": "test_jr8",
          "category": "function",
          "description": "Tests the JR instruction.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs when there is an issue with memory access."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns Ok(()) if the test passes."
          },
          "prototype": "fn test_jr8() -> Result<(), MemError> {}"
        },
        {
          "name": "test_jrcc8",
          "category": "function",
          "description": "Tests the JRCC8 instruction.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs when there is an issue with memory access."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns Ok(()) if the test passes."
          },
          "prototype": "fn test_jrcc8() -> Result<(), MemError> {}"
        }
      ],
      "examples": [
        {
          "title": "Example: test_jr8",
          "description": "Runs the test_jr8 function.",
          "example": "cargo test -p project-crate",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example: test_jrcc8",
          "description": "Runs the test_jrcc8 function.",
          "example": "cargo test -p project-crate",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_ld00a_normal() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.cpu.r[reg::A as usize] = 0x42;\n    state.cpu.w16(reg::B, 0x1000);\n    state.mem.w(0, 0b00000010)?; // Opcode for LD (BC), A\n    exec_opcode(&mut state)?;\n    assert_eq!(state.mem.r(0x1000)?, 0x42);\n    Ok(())\n}\n\n#[test]\nfn test_ld00a_hl_plus() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.cpu.r[reg::A as usize] = 0x42;\n    state.cpu.w16(reg::HL, 0x1000);\n    state.mem.w(0, 0b00100010)?; // Opcode for LD (HL+), A\n    exec_opcode(&mut state)?;\n    assert_eq!(state.mem.r(0x1000)?, 0x42);\n    assert_eq!(state.cpu.r16(reg::HL), 0x1001); // Check if HL was incremented\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_3.rs",
    "path": "src/tests/instructions_tests_chunk_3.rs",
    "originalPath": "src/tests/instructions_tests_chunk_3.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains test functions for two opcode instructions: LD (BC), A and LD (HL+), A. These functions test the functionality of the LD opcode instructions of a GBState struct. The LD opcode is used to load values from register A into the memory locations specified by registers BC or HL. The tests initialize a GBState struct and set the value of register A to 0x42. Then, an opcode is written to memory location 0 to specify the LD (BC), A or LD (HL+), A instruction. The exec_opcode function is called to execute the opcode instruction. Finally, the tests assert that the memory location specified by register BC or HL contains the value of register A. For the LD (HL+), A instruction, the test also asserts that register HL is incremented after the execution of the opcode.",
      "references": [
        {
          "name": "test_ld00a_normal",
          "category": "function",
          "description": "This function tests the LD (BC), A instruction by loading the value of register A into the memory location specified by registers BC. It asserts that the memory location contains the value of register A.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur if there's an issue reading/writing to memory."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns Ok(()) if the test passes."
          },
          "prototype": "fn test_ld00a_normal() -> Result<(), MemError>"
        },
        {
          "name": "test_ld00a_hl_plus",
          "category": "function",
          "description": "This function tests the LD (HL+), A instruction by loading the value of register A into the memory location specified by register HL. It asserts that the memory location contains the value of register A and that register HL is incremented after the execution of the opcode.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur if there's an issue reading/writing to memory."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns Ok(()) if the test passes."
          },
          "prototype": "fn test_ld00a_hl_plus() -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example Test LD (BC), A",
          "description": "An example test for LD (BC), A instruction.",
          "example": "rust -m test instructions_tests_chunk_3::test_ld00a_normal",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example Test LD (HL+), A",
          "description": "An example test for LD (HL+), A instruction.",
          "example": "rust -m test instructions_tests_chunk_3::test_ld00a_hl_plus",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_ld00a_hl_minus() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.cpu.r[reg::A as usize] = 0x42;\n    state.cpu.w16(reg::HL, 0x1000);\n    state.mem.w(0, 0b00110010)?; // Opcode for LD (HL-), A\n    exec_opcode(&mut state)?;\n    assert_eq!(state.mem.r(0x1000)?, 0x42);\n    assert_eq!(state.cpu.r16(reg::HL), 0xfff);\n    Ok(())\n}\n\n#[test]\nfn test_inc8() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00000100)?; // Opcode for INC B\n    state.cpu.r[reg::B as usize] = 42;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::B as usize], 43);\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_4.rs",
    "path": "src/tests/instructions_tests_chunk_4.rs",
    "originalPath": "src/tests/instructions_tests_chunk_4.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains test functions for the GBState struct and the exec_opcode function. The test_ld00a_hl_minus function tests the LD (HL-), A opcode. It initializes a GBState struct, sets the value of register A to 0x42, sets the HL register to 0x1000, writes the opcode for LD (HL-), A to memory address 0, executes the opcode using exec_opcode, and asserts that the value at memory address 0x1000 is 0x42 and the value of the HL register is decremented by 1. The test_inc8 function tests the INC B opcode. It initializes a GBState struct, writes the opcode for INC B to memory address 0, sets the value of register B to 42, executes the opcode using exec_opcode, and asserts that the value of register B is incremented by 1.",
      "references": [
        {
          "name": "test_ld00a_hl_minus",
          "category": "function",
          "description": "Tests the LD (HL-), A opcode by initializing a GBState struct, setting register A to 0x42, setting the HL register to 0x1000, writing the opcode to memory, executing the opcode, and asserting the memory value and HL register value.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while accessing the memory."
            }
          ],
          "keywords": [
            "test",
            "LD",
            "opcode",
            "GBState",
            "exec_opcode",
            "memory"
          ],
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns Ok(()) if the test passes, or an Err(MemError) if an error occurs."
          },
          "prototype": "fn test_ld00a_hl_minus() -> Result<(), MemError>"
        },
        {
          "name": "test_inc8",
          "category": "function",
          "description": "Tests the INC B opcode by initializing a GBState struct, writing the opcode to memory, setting register B to 42, executing the opcode, and asserting the register B value.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while accessing the memory."
            }
          ],
          "keywords": [
            "test",
            "INC",
            "opcode",
            "GBState",
            "exec_opcode",
            "memory"
          ],
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns Ok(()) if the test passes, or an Err(MemError) if an error occurs."
          },
          "prototype": "fn test_inc8() -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Test LD (HL-), A",
          "description": "Example test for the LD (HL-), A opcode.",
          "example": "python -m module_name instructions_tests_chunk_4.rs",
          "example_markdown_language": "bash"
        },
        {
          "title": "Test INC B",
          "description": "Example test for the INC B opcode.",
          "example": "python -m module_name instructions_tests_chunk_4.rs",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_dec8() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00000101)?; // Opcode for DEC B\n    state.cpu.r[reg::B as usize] = 42;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::B as usize], 41);\n    Ok(())\n}\n\n#[test]\nfn test_ccf() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00111111)?; // Opcode for CCF\n    state.cpu.r[reg::F as usize] = 0b00010000; // Set the carry flag\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::F as usize] & 0b00010000, 0); // Check if carry flag is reset\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_5.rs",
    "path": "src/tests/instructions_tests_chunk_5.rs",
    "originalPath": "src/tests/instructions_tests_chunk_5.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains unit tests for two functions: 'test_dec8' and 'test_ccf'. The 'test_dec8' function tests the functionality of the 'DEC' opcode, which decrements the value of register B in the GBState CPU. The 'test_ccf' function tests the functionality of the 'CCF' opcode, which resets the carry flag in the GBState CPU register F. The file imports the necessary dependencies and defines the 'GBState' struct and 'exec_opcode' function. The functions use assertions to check the expected values of the CPU registers after executing the opcodes.",
      "references": [
        {
          "name": "test_dec8",
          "category": "function",
          "description": "This function tests the 'DEC' opcode functionality by creating a new 'GBState' instance, setting the value of register B to 42, and executing the opcode. The value of register B is then compared with the expected result, which is 41.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when accessing and modifying memory in the 'GBState' structure."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A result indicating whether the test was successful or if an error occurred."
          },
          "prototype": "fn test_dec8() -> Result<(), MemError> { ... }"
        },
        {
          "name": "test_ccf",
          "category": "function",
          "description": "This function tests the 'CCF' opcode functionality by creating a new 'GBState' instance, setting the value of register F to indicate the carry flag, and executing the opcode. It then checks if the carry flag is reset in the GBState.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when accessing and modifying memory in the 'GBState' structure."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A result indicating whether the test was successful or if an error occurred."
          },
          "prototype": "fn test_ccf() -> Result<(), MemError> { ... }"
        }
      ],
      "examples": [
        {
          "title": "Example: test_dec8",
          "description": "This example demonstrates how to use the 'test_dec8' function.",
          "example": "// Test the DEC opcode\n<base_command>",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example: test_ccf",
          "description": "This example demonstrates how to use the 'test_ccf' function.",
          "example": "// Test the CCF opcode\n<base_command>",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_scf() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00110111)?; // Opcode for SCF\n    state.cpu.r[reg::F as usize] = 0; // Reset the carry flag\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::F as usize] & 0b00010000, 0b00010000); // Check if carry flag is set\n    Ok(())\n}\n\n#[test]\nfn test_cpl() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00101111)?; // Opcode for CPL\n    state.cpu.r[reg::A as usize] = 0b10101010;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 0b01010101); // Check if all bits in A have been flipped\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_6.rs",
    "path": "src/tests/instructions_tests_chunk_6.rs",
    "originalPath": "src/tests/instructions_tests_chunk_6.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains test functions for the SCF and CPL opcodes. The 'test_scf' function tests if the carry flag is set correctly after executing the SCF opcode. The 'test_cpl' function tests if all bits in register A are flipped after executing the CPL opcode.",
      "references": [
        {
          "name": "test_scf",
          "category": "function",
          "description": "Tests if the carry flag is set correctly after executing the SCF opcode.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs if there is a problem accessing memory."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "The result indicating success or failure."
          },
          "prototype": "fn test_scf() -> Result<(), MemError> { ... }"
        },
        {
          "name": "test_cpl",
          "category": "function",
          "description": "Tests if all bits in register A are flipped after executing the CPL opcode.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs if there is a problem accessing memory."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "The result indicating success or failure."
          },
          "prototype": "fn test_cpl() -> Result<(), MemError> { ... }"
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes an opcode.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that occurs if there is a problem accessing memory."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "The current state of the Game Boy."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "The result indicating success or failure."
          },
          "prototype": "fn exec_opcode(&mut state: GBState) -> Result<(), MemError> { ... }"
        },
        {
          "name": "GBState",
          "category": "type",
          "description": "The state of the Game Boy.",
          "parameters": [],
          "returns": null
        },
        {
          "name": "MemError",
          "category": "type",
          "description": "An error that occurs if there is a problem accessing memory.",
          "parameters": [],
          "returns": null
        },
        {
          "name": "reg",
          "category": "structure",
          "description": "A structure that represents registers.",
          "parameters": [],
          "returns": null
        }
      ],
      "examples": [
        {
          "title": "Example: test_scf",
          "description": "Tests if the carry flag is set correctly after executing the SCF opcode.",
          "example": "cargo test",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example: test_cpl",
          "description": "Tests if all bits in register A are flipped after executing the CPL opcode.",
          "example": "cargo test",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_daa_add_1() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00100111)?; // DAA opcode\n    state.cpu.r[reg::A as usize] = 0x1B;\n\n    exec_opcode(&mut state)?;\n\n    assert_eq!(state.cpu.r[reg::A as usize], 0x21);\n\n    Ok(())\n}\n\n#[test]\nfn test_daa_add_2() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00100111)?; // DAA opcode\n    state.cpu.r[reg::A as usize] = 0x37 + 0x9;\n    state.cpu.r[reg::F as usize] = flag::H;\n\n    exec_opcode(&mut state)?;\n\n    assert_eq!(state.cpu.r[reg::A as usize], 0x46);\n\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_7.rs",
    "path": "src/tests/instructions_tests_chunk_7.rs",
    "originalPath": "src/tests/instructions_tests_chunk_7.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains test cases for the `exec_opcode` function, specifically testing the 'DAA' opcode. The `test_daa_add_1` function tests the addition of two numbers using the 'DAA' instruction. The `test_daa_add_2` function also tests the addition of two numbers, but with a carry flag set. Both test cases assert the result of the addition and return `Ok(())` if the assertions pass.",
      "references": [
        {
          "name": "test_daa_add_1",
          "category": "function",
          "description": "Tests the addition of two numbers using the 'DAA' instruction.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while writing data to memory."
            }
          ],
          "publics": true,
          "parameters": [],
          "returns": null,
          "prototype": "fn test_daa_add_1() -> Result<(), MemError>"
        },
        {
          "name": "test_daa_add_2",
          "category": "function",
          "description": "Tests the addition of two numbers with a carry flag set using the 'DAA' instruction.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while writing data to memory."
            }
          ],
          "publics": true,
          "parameters": [],
          "returns": null,
          "prototype": "fn test_daa_add_2() -> Result<(), MemError>"
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes the opcode provided in the GBState using the Game Boy CPU.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while writing data to memory."
            }
          ],
          "publics": true,
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "The Game Boy State containing CPU and memory information."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the opcode was executed successfully, or an error if encountered."
          },
          "prototype": "fn exec_opcode(state: &mut GBState) -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example usage of `test_daa_add_1`",
          "description": "This example demonstrates how to use the `test_daa_add_1` test case function.",
          "example": "// Run the `test_daa_add_1` test case\n<cargo bin>/test [OPTIONS]",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example usage of `test_daa_add_2`",
          "description": "This example demonstrates how to use the `test_daa_add_2` test case function.",
          "example": "// Run the `test_daa_add_2` test case\n<cargo bin>/test [OPTIONS]",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example usage of `exec_opcode`",
          "description": "This example demonstrates how to use the `exec_opcode` function within the test cases.",
          "example": "fn test_daa_add_1() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00100111)?; // DAA opcode\n    state.cpu.r[reg::A as usize] = 0x1B;\n\n    exec_opcode(&mut state)?;\n\n    assert_eq!(state.cpu.r[reg::A as usize], 0x21);\n\n    Ok(())\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_daa_sub_1() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00100111)?; // DAA opcode\n    state.cpu.r[reg::A as usize] = 0x1F;\n    state.cpu.r[reg::F as usize] = flag::N;\n\n    exec_opcode(&mut state)?;\n\n    assert_eq!(state.cpu.r[reg::A as usize], 0x19);\n\n    Ok(())\n}\n\n#[test]\nfn test_daa_sub_2() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b00100111)?; // DAA opcode\n    state.cpu.r[reg::A as usize] = 0x30 - 0x9;\n    state.cpu.r[reg::F as usize] = flag::N | flag::H;\n\n    exec_opcode(&mut state)?;\n\n    assert_eq!(state.cpu.r[reg::A as usize], 0x21);\n\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_8.rs",
    "path": "src/tests/instructions_tests_chunk_8.rs",
    "originalPath": "src/tests/instructions_tests_chunk_8.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains unit tests for the `daa` instruction in a Game Boy emulator. The `daa` instruction performs decimal adjust on the accumulation register (`A`) based on the flags in the flag register (`F`). The tests cover scenarios where `daa` is called in subtraction mode and adjust the result of the subtraction accordingly.",
      "references": [
        {
          "name": "test_daa_sub_1",
          "category": "function",
          "description": "Tests decimal adjust on the accumulation register (`A`) when subtracting. Sets the `A` register to 0x1F, the `F` register to the negative flag, and executes the `daa` instruction. Asserts that the `A` register is updated to 0x19.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while performing memory operations."
            }
          ],
          "keywords": [
            "test",
            "daa",
            "subtraction",
            "accumulation register",
            "flag register"
          ],
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "An `Ok` value indicating the test passed or an `Err` value containing a `MemError` if an error occurred."
          },
          "prototype": "fn test_daa_sub_1() -> Result<(), MemError>"
        },
        {
          "name": "test_daa_sub_2",
          "category": "function",
          "description": "Tests decimal adjust on the accumulation register (`A`) when subtracting. Sets the `A` register to 0x30 - 0x9, the `F` register to the negative flag and half carry flag, and executes the `daa` instruction. Asserts that the `A` register is updated to 0x21.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while performing memory operations."
            }
          ],
          "keywords": [
            "test",
            "daa",
            "subtraction",
            "accumulation register",
            "flag register"
          ],
          "publics": true,
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "An `Ok` value indicating the test passed or an `Err` value containing a `MemError` if an error occurred."
          },
          "prototype": "fn test_daa_sub_2() -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Test Decimal Adjust on Accumulation Register - Subtraction 1",
          "description": "This example demonstrates how to perform decimal adjust on the accumulation register (`A`) when subtracting.",
          "example": "// Test Decimal Adjust on Accumulation Register - Subtraction 1\n// Executes the test_daa_sub_1 function\n// Runs the test\n\n// Example: cargo test --package my_package\n// Example: cargo test --package my_package instructions_tests_chunk_8::test_daa_sub_1\n// Example: cargo test --package my_package -p instructions_tests_chunk_8::test_daa_sub_1",
          "example_markdown_language": "rust"
        },
        {
          "title": "Test Decimal Adjust on Accumulation Register - Subtraction 2",
          "description": "This example demonstrates how to perform decimal adjust on the accumulation register (`A`) when subtracting.",
          "example": "// Test Decimal Adjust on Accumulation Register - Subtraction 2\n// Executes the test_daa_sub_2 function\n// Runs the test\n\n// Example: cargo test --package my_package\n// Example: cargo test --package my_package instructions_tests_chunk_8::test_daa_sub_2\n// Example: cargo test --package my_package -p instructions_tests_chunk_8::test_daa_sub_2",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_add() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10000000)?; // Opcode for ADD A, B\n    state.cpu.r[reg::A as usize] = 10;\n    state.cpu.r[reg::B as usize] = 15;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 25);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, 0); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, flag::H); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, 0); // Check Carry Flag\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_9.rs",
    "path": "src/tests/instructions_tests_chunk_9.rs",
    "originalPath": "src/tests/instructions_tests_chunk_9.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains a unit test for an `add` function. The test verifies that the `add` function correctly adds the values in register A and register B, updates the flags accordingly, and stores the result in register A. The `GBState` struct represents the state of the Game Boy CPU and Memory. The test initializes the state with values of 10 for register A and 15 for register B. It then sets the memory at address 0 to the opcode for `ADD A, B`. The `exec_opcode` function is called to execute the opcode, updating the state. The test asserts that the value of register A is now 25 and checks the flags (ZF, N, H, CY) to ensure they are correct. If all assertions pass, the test returns Ok().",
      "references": [
        {
          "name": "test_add",
          "category": "function",
          "description": "Unit test for the `add` function.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when accessing memory."
            }
          ]
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes the opcode in the current state, updating the state accordingly.",
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "The current state of the Game Boy CPU and Memory."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "A result indicating success or failure, with a possible MemError."
          }
        }
      ],
      "examples": [
        {
          "title": "Unit Test",
          "description": "Example command to run the unit test.",
          "example": "cargo test --test instructions_tests_chunk_9",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_adc() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10001000)?; // Opcode for ADC A, B\n    state.cpu.r[reg::A as usize] = 10;\n    state.cpu.r[reg::B as usize] = 15;\n    state.cpu.r[reg::F as usize] |= flag::CY; // Set Carry Flag\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 26);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, 0); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, flag::H); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, 0); // Check Carry Flag\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_10.rs",
    "path": "src/tests/instructions_tests_chunk_10.rs",
    "originalPath": "src/tests/instructions_tests_chunk_10.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "The provided code is a unit test for the ADC (Add with Carry) instruction in a Game Boy emulator. The test sets up the game state with an opcode for ADC A, B, sets the values of registers A and B, and sets the Carry flag. The `exec_opcode` function is then called to execute the instruction. The test asserts that the resulting values of register A and the flags are as expected. The test function returns a `Result` indicating success or failure.",
      "references": [
        {
          "name": "test_adc",
          "category": "function",
          "description": "Unit test for the ADC (Add with Carry) instruction.",
          "errors": [
            {
              "name": "MemError",
              "description": "Error when accessing memory."
            }
          ]
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes the given opcode and updates the game state."
        },
        {
          "name": "GBState::new",
          "category": "method",
          "description": "Creates a new game state."
        },
        {
          "name": "state.mem.w",
          "category": "method",
          "description": "Writes a value to memory at the specified address."
        },
        {
          "name": "reg::A",
          "category": "struct",
          "description": "Enumeration variant representing register A."
        },
        {
          "name": "reg::B",
          "category": "struct",
          "description": "Enumeration variant representing register B."
        },
        {
          "name": "reg::F",
          "category": "struct",
          "description": "Enumeration variant representing register F."
        },
        {
          "name": "flag::CY",
          "category": "constant",
          "description": "Constant representing the Carry flag."
        },
        {
          "name": "assert_eq!",
          "category": "macro",
          "description": "Macro for asserting equality between two values."
        }
      ],
      "examples": [
        {
          "title": "ADC instruction unit test",
          "description": "This example demonstrates a unit test for the ADC (Add with Carry) instruction.",
          "example": "fn test_adc() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10001000)?; // Opcode for ADC A, B\n    state.cpu.r[reg::A as usize] = 10;\n    state.cpu.r[reg::B as usize] = 15;\n    state.cpu.r[reg::F as usize] |= flag::CY; // Set Carry Flag\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 26);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, 0); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, flag::H); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, 0); // Check Carry Flag\n    Ok(())\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_sub() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10010000)?; // Opcode for SUB A, B\n    state.cpu.r[reg::A as usize] = 20;\n    state.cpu.r[reg::B as usize] = 15;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 5);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, flag::N); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, flag::H); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, 0); // Check Carry Flag\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_11.rs",
    "path": "src/tests/instructions_tests_chunk_11.rs",
    "originalPath": "src/tests/instructions_tests_chunk_11.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "The provided code is a unit test written in Rust that tests the execution of an opcode SUB A, B. This opcode subtracts the value in register B from the value in register A and stores the result in register A. The test initializes a GBState struct, sets the values of register A and B, and executes the opcode using exec_opcode function. Then, it asserts that the value in register A is 5 and checks the status flags: Zero Flag (ZF), Subtract Flag (N), Half Carry Flag (H), and Carry Flag (CY). The test returns Ok(()) if all the assertions pass.",
      "references": [
        {
          "name": "test_sub",
          "category": "function",
          "description": "Unit test for opcode SUB A, B.",
          "errors": [
            {
              "name": "Result",
              "description": "Error type representing the possible errors that can occur."
            },
            {
              "name": "MemError",
              "description": "Error type representing a memory-related error."
            }
          ]
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Function that executes an opcode.",
          "parameters": [
            {
              "name": "state",
              "type": "&mut GBState",
              "description": "Mutable reference to a GBState object."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Result indicating success or a MemError."
          }
        },
        {
          "name": "GBState",
          "category": "struct",
          "description": "Struct that represents the state of the Game Boy."
        },
        {
          "name": "GBState::new",
          "category": "method",
          "description": "Method that creates a new GBState object."
        },
        {
          "name": "state.mem.w",
          "category": "method",
          "description": "Method that writes a value to memory.",
          "parameters": [
            {
              "name": "address",
              "type": "u16",
              "description": "The memory address."
            },
            {
              "name": "value",
              "type": "u8",
              "description": "The value to write."
            }
          ]
        },
        {
          "name": "state.cpu.r",
          "category": "method",
          "description": "Method that accesses the CPU registers."
        },
        {
          "name": "reg::A",
          "category": "type",
          "description": "Constant representing register A."
        },
        {
          "name": "reg::B",
          "category": "type",
          "description": "Constant representing register B."
        },
        {
          "name": "flag::ZF",
          "category": "type",
          "description": "Constant representing the Zero Flag."
        },
        {
          "name": "flag::N",
          "category": "type",
          "description": "Constant representing the Subtract Flag."
        },
        {
          "name": "flag::H",
          "category": "type",
          "description": "Constant representing the Half Carry Flag."
        },
        {
          "name": "flag::CY",
          "category": "type",
          "description": "Constant representing the Carry Flag."
        },
        {
          "name": "assert_eq!",
          "category": "macro",
          "description": "Macro that asserts equality between two values."
        },
        {
          "name": "Ok",
          "category": "struct",
          "description": "Struct representing a successful result."
        },
        {
          "name": "() as usize",
          "category": "expression",
          "description": "Expression that converts a value to usize."
        }
      ],
      "examples": [
        {
          "title": "Test SUB A, B",
          "description": "Example code that demonstrates how to test opcode SUB A, B.",
          "example": "fn main() {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10010000).unwrap(); // Opcode for SUB A, B\n    state.cpu.r[reg::A as usize] = 20;\n    state.cpu.r[reg::B as usize] = 15;\n    exec_opcode(&mut state).unwrap();\n    assert_eq!(state.cpu.r[reg::A as usize], 5);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, flag::N); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, flag::H); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, 0); // Check Carry Flag\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_sbc() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10011000)?; // Opcode for SBC A, B\n    state.cpu.r[reg::A as usize] = 10;\n    state.cpu.r[reg::B as usize] = 3;\n    state.cpu.r[reg::F as usize] |= flag::CY; // Set Carry Flag\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 6);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, flag::N); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, 0); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, 0); // Check Carry Flag\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_12.rs",
    "path": "src/tests/instructions_tests_chunk_12.rs",
    "originalPath": "src/tests/instructions_tests_chunk_12.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains a test case for the function test_sbc(). The test case sets up the GBState with specific values and executes the opcode for the SBC A, B instruction. It then asserts the expected state of the GBState after executing the opcode.",
      "references": [
        {
          "name": "test_sbc",
          "category": "function",
          "description": "This function is a test case for the opcode SBC A, B. It verifies that the subtraction is performed correctly and that the flags are set accordingly.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error occurred while writing to memory."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "This function returns a Result indicating whether the test case passed or failed."
          },
          "prototype": "fn test_sbc() -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example usage of test_sbc function",
          "description": "In this example, the test_sbc function is used to test the SBC A, B opcode.",
          "example": "test_sbc().unwrap();",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_and() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10100000)?; // Opcode for AND A, B\n    state.cpu.r[reg::A as usize] = 0b10101010;\n    state.cpu.r[reg::B as usize] = 0b11001100;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 0b10001000);\n    Ok(())\n}\n\n#[test]\nfn test_xor() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10101000)?; // Opcode for XOR A, B\n    state.cpu.r[reg::A as usize] = 0b10101010;\n    state.cpu.r[reg::B as usize] = 0b11001100;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 0b01100110);\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_13.rs",
    "path": "src/tests/instructions_tests_chunk_13.rs",
    "originalPath": "src/tests/instructions_tests_chunk_13.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains test functions for the logic operations `AND` and `XOR` in a Game Boy emulator. The `test_and` function tests the `AND` opcode by initializing a `GBState` struct, writing the opcode and values to the memory, setting the values of registers A and B, executing the opcode, and asserting the correct result. The `test_xor` function follows a similar pattern but tests the `XOR` opcode instead.",
      "references": [
        {
          "name": "test_and",
          "category": "function",
          "description": "Tests the `AND` opcode.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when accessing memory."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the test is successful, otherwise an error is returned."
          },
          "prototype": "fn test_and() -> Result<(), MemError>"
        },
        {
          "name": "test_xor",
          "category": "function",
          "description": "Tests the `XOR` opcode.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when accessing memory."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the test is successful, otherwise an error is returned."
          },
          "prototype": "fn test_xor() -> Result<(), MemError>"
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes the given opcode.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when accessing memory."
            }
          ],
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "The state of the Game Boy."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the opcode is successfully executed, otherwise an error is returned."
          },
          "prototype": "fn exec_opcode(state: &mut GBState) -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Example for test_and",
          "description": "Runs the `test_and` function.",
          "example": "cargo test --bin <base_command> instructions_tests_chunk_13::test_and",
          "example_markdown_language": "bash"
        },
        {
          "title": "Example for test_xor",
          "description": "Runs the `test_xor` function.",
          "example": "cargo test --bin <base_command> instructions_tests_chunk_13::test_xor",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_or() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10110000)?; // Opcode for OR A, B\n    state.cpu.r[reg::A as usize] = 0b10101010;\n    state.cpu.r[reg::B as usize] = 0b11001100;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 0b11101110);\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_14.rs",
    "path": "src/tests/instructions_tests_chunk_14.rs",
    "originalPath": "src/tests/instructions_tests_chunk_14.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains a test function `test_or` that checks the functionality of the OR operation. The function creates a `GBState` object and initializes the memory and registers. It then sets the value of register `A` to `0b10101010` and the value of register `B` to `0b11001100`. Next, it writes the opcode for the OR operation (`OR A, B`) to the memory. The `exec_opcode` function is then called to execute the opcode, resulting in the OR operation being performed on the values of register `A` and `B`, and the result being stored in register `A`. Finally, the function asserts that the value of register `A` is equal to `0b11101110` and returns `Ok(())`.",
      "references": [
        {
          "name": "test_or",
          "category": "function",
          "description": "A test function that checks the functionality of the OR operation.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when writing to memory."
            }
          ]
        },
        {
          "name": "GBState",
          "category": "class",
          "description": "A struct representing the state of the Game Boy system.",
          "subreferences": [
            {
              "name": "new",
              "category": "method",
              "description": "A method that creates a new `GBState` object.",
              "returns": {
                "type": "GBState",
                "description": "The created `GBState` object."
              }
            }
          ]
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "A function that executes the opcode stored in memory.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur when reading from memory."
            }
          ]
        },
        {
          "name": "reg",
          "category": "enum",
          "description": "An enum representing the CPU registers.",
          "enum": [
            "A",
            "B"
          ]
        }
      ],
      "examples": [
        {
          "title": "Test OR Operation",
          "description": "This example demonstrates how to use the `test_or` function.",
          "example": "fn main() {\n    test_or().unwrap();\n}",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_cp() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.mem.w(0, 0b10111000)?; // Opcode for CP A, B\n    state.cpu.r[reg::A as usize] = 20;\n    state.cpu.r[reg::B as usize] = 15;\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 20);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, flag::N); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, flag::H); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, 0); // Check Carry Flag\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_15.rs",
    "path": "src/tests/instructions_tests_chunk_15.rs",
    "originalPath": "src/tests/instructions_tests_chunk_15.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains a test case for the `cp` function. The `cp` function is used to compare the value of two registers in a Game Boy emulator. The test case sets the values of registers `A` and `B` to 20 and 15 respectively. It then executes the `cp` opcode and asserts various conditions to verify the correctness of the comparison. This test case is part of the larger test suite for the emulator.",
      "references": [
        {
          "name": "test_cp",
          "category": "function",
          "description": "Executes the test case for the `cp` instruction in the emulator.",
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the test case passes or an error if it fails."
          }
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes an opcode in the Game Boy emulator.",
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "The state of the Game Boy emulator."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the opcode executes successfully or an error if it fails."
          }
        },
        {
          "name": "GBState",
          "category": "struct",
          "description": "Represents the state of the Game Boy emulator.",
          "subreferences": [
            {
              "name": "new",
              "category": "method",
              "description": "Creates a new `GBState` instance.",
              "parameters": [],
              "returns": {
                "type": "GBState",
                "description": "Returns a new `GBState` instance."
              }
            }
          ]
        },
        {
          "name": "MemError",
          "category": "enum",
          "description": "Represents an error that can occur during memory access in the emulator.",
          "enum": [
            "InvalidAddress",
            "ReadWriteError"
          ]
        },
        {
          "name": "reg",
          "category": "enum",
          "description": "Represents the available registers in the Game Boy CPU.",
          "enum": [
            "A",
            "B",
            "F"
          ]
        },
        {
          "name": "flag",
          "category": "enum",
          "description": "Represents the available flags in the Game Boy CPU.",
          "enum": [
            "ZF",
            "N",
            "H",
            "CY"
          ]
        }
      ],
      "examples": [
        {
          "title": "Example",
          "description": "Execute the `test_cp` test case.",
          "example": "// Run the test case\n<base_command> --bin emulator",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_rlca() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.cpu.r[reg::A as usize] = 0b10011100;\n    state.cpu.r[reg::F as usize] = 0;\n    state.mem.w(0, 0b00000111)?; // Opcode for RLCA\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 0b00111001);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, 0); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, 0); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, flag::CY); // Check Carry Flag\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_16.rs",
    "path": "src/tests/instructions_tests_chunk_16.rs",
    "originalPath": "src/tests/instructions_tests_chunk_16.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains a test case for the `rlca` function. The function is called to test the rotate left through carry operation on the A register of the Game Boy CPU. The function sets up a GBState object with initial values for the CPU registers and memory. It then calls the `exec_opcode` function to execute the opcode for RLCA. After the execution, the function asserts that the A register has been rotated left through carry correctly. It also checks the flags register to ensure that the Zero Flag, Subtract Flag, Half Carry Flag, and Carry Flag are set or cleared as expected. If any error occurs during the execution or assertion, a `MemError` is returned.",
      "references": [
        {
          "name": "test_rlca",
          "category": "function",
          "description": "Tests the rotate left through carry operation on the A register of the Game Boy CPU.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur during memory operations."
            }
          ]
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes the opcode for a given instruction.",
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "The state of the Game Boy CPU and memory."
            }
          ]
        },
        {
          "name": "GBState",
          "category": "struct",
          "description": "Represents the state of the Game Boy CPU and memory.",
          "subreferences": [
            {
              "name": "cpu",
              "category": "structure",
              "description": "Represents the registers of the Game Boy CPU."
            },
            {
              "name": "mem",
              "category": "structure",
              "description": "Represents the memory of the Game Boy."
            }
          ]
        },
        {
          "name": "reg",
          "category": "enum",
          "description": "Enumerates the registers of the Game Boy CPU."
        },
        {
          "name": "flag",
          "category": "enum",
          "description": "Contains bit flags for the Game Boy CPU flags register."
        }
      ],
      "examples": [
        {
          "title": "Example",
          "description": "Example usage of the `test_rlca` function.",
          "example": "fn main() {\n    test_rlca().unwrap();\n}\n",
          "example_markdown_language": "rust"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_rrca() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.cpu.r[reg::A as usize] = 0b10011100;\n    state.cpu.r[reg::F as usize] = 0;\n    state.mem.w(0, 0b00001111)?; // Opcode for RLCA\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 0b01001110);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, 0); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, 0); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, 0); // Check Carry Flag\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_17.rs",
    "path": "src/tests/instructions_tests_chunk_17.rs",
    "originalPath": "src/tests/instructions_tests_chunk_17.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This JSON object provides examples and references for the functions defined in the `src/tests/instructions_tests_chunk_17.rs` file. The code in this file contains a test function `test_rrca` which tests the execution of the `RRCA` instruction in a Game Boy emulator. It verifies if the `RRCA` opcode rotates the value of register A to the right, updates the necessary flags, and returns the expected result.",
      "references": [
        {
          "name": "test_rrca",
          "category": "function",
          "description": "Test function for the RRCA instruction.",
          "errors": [
            {
              "name": "Result",
              "description": "Error returned if there is a memory error."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if the test is successful."
          },
          "prototype": "fn test_rrca() -> Result<(), MemError>"
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes the opcode provided as a parameter.",
          "parameters": [
            {
              "name": "state",
              "type": "GBState",
              "description": "The Game Boy emulator state."
            }
          ],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns `Ok(())` if opcode execution is successful."
          },
          "prototype": "fn exec_opcode(state: &mut GBState) -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Test RRCA Instruction",
          "description": "This example demonstrates how to use the `test_rrca` function to test the RRCA instruction.",
          "example": "cargo test",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_rla() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.cpu.r[reg::A as usize] = 0b00011100;\n    state.cpu.r[reg::F as usize] = flag::CY;\n    state.mem.w(0, 0b00010111)?; // Opcode for RLA\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 0b00111001);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, 0); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, 0); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, 0); // Check Carry Flag\n    Ok(())\n}\n\n#[test]",
    "name": "instructions_tests_chunk_18.rs",
    "path": "src/tests/instructions_tests_chunk_18.rs",
    "originalPath": "src/tests/instructions_tests_chunk_18.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This JSON object includes example code and references for the content provided in the file src/tests/instructions_tests_chunk_18.rs. The code is related to testing the RLA opcode and checking various CPU flags. The examples are runnable from the root of the project.",
      "references": [
        {
          "name": "test_rla",
          "category": "function",
          "description": "This function tests the behavior of the RLA opcode and checks various CPU flags.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error that can occur while accessing memory."
            },
            {
              "name": "AssertionError",
              "description": "An error that occurs when the test assertions fail."
            }
          ],
          "parameters": [],
          "returns": {
            "type": "Result<(), MemError>",
            "description": "Returns the result of the test, indicating success or an error."
          },
          "prototype": "fn test_rla() -> Result<(), MemError>"
        }
      ],
      "examples": [
        {
          "title": "Test RLA Opcode",
          "description": "Example code demonstrating the usage of the test_rla function.",
          "example": "cargo test --test instructions_tests_chunk_18",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  },
  {
    "content": "fn test_rra() -> Result<(), MemError> {\n    let mut state = GBState::new();\n    state.cpu.r[reg::A as usize] = 0b00011101;\n    state.cpu.r[reg::F as usize] = flag::CY;\n    state.mem.w(0, 0b00011111)?; // Opcode for RLA\n    exec_opcode(&mut state)?;\n    assert_eq!(state.cpu.r[reg::A as usize], 0b10001110);\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::ZF, 0); // Check Zero Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::N, 0); // Check Subtract Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::H, 0); // Check Half Carry Flag\n    assert_eq!(state.cpu.r[reg::F as usize] & flag::CY, flag::CY); // Check Carry Flag\n    Ok(())\n}",
    "name": "instructions_tests_chunk_19.rs",
    "path": "src/tests/instructions_tests_chunk_19.rs",
    "originalPath": "src/tests/instructions_tests_chunk_19.rs",
    "chunkTotal": 20,
    "reference_json": {
      "description": "This file contains a test function, `test_rra`, which tests the `exec_opcode` function with a specific opcode. It creates a GBState object, sets the value of the A register, and sets the CY flag in the F register. Then, it writes an opcode to memory, calls `exec_opcode`, and asserts that the A register is updated correctly. It also checks the ZF, N, H, and CY flags in the F register. The function returns a `Result<(), MemError>`.",
      "references": [
        {
          "name": "test_rra",
          "category": "function",
          "description": "Tests the `exec_opcode` function with a specific opcode. Verifies the behavior of the A and F registers after executing the opcode.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error indicating a memory access failure during executing the opcode."
            }
          ]
        },
        {
          "name": "exec_opcode",
          "category": "function",
          "description": "Executes the opcode stored in memory, updating the state of the CPU registers based on the opcode's behavior.",
          "errors": [
            {
              "name": "MemError",
              "description": "An error indicating a memory access failure during opcode execution."
            }
          ]
        }
      ],
      "examples": [
        {
          "title": "Test RRA opcode execution",
          "description": "This example demonstrates how to use the `test_rra` function to test the execution of the RRA opcode.",
          "example": "cargo test --package <package_name>",
          "example_markdown_language": "bash"
        }
      ]
    },
    "chunk": 1
  }
]